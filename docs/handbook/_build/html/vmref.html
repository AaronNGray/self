<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Virtual Machine Reference &mdash; Self Handbook for Self 4.5.0 documentation</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'for Self 4.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="top" title="Self Handbook for Self 4.5.0 documentation" href="index.html" />
    <link rel="next" title="Building a VM" href="buildvm.html" />
    <link rel="prev" title="Morphic: The Self User Interface Framework" href="morphic.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Self Handbook for Self 4.5.0 documentation</span></a></h1>
        <h2 class="heading"><span>Virtual Machine Reference</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="morphic.html">Morphic: The Self User Interface Framework</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="buildvm.html">Building a VM</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="virtual-machine-reference">
<h1>Virtual Machine Reference<a class="headerlink" href="#virtual-machine-reference" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="buildvm.html">Building a VM</a></li>
</ul>
</div>
<div class="section" id="startup-options">
<h2>Startup options<a class="headerlink" href="#startup-options" title="Permalink to this headline">¶</a></h2>
<p>The following command-line options are recognised by the Virtual Machine:</p>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="97%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>-f</td>
<td>filename Reads filename (which should contain Self source) immediately after startup (after reading the snapshot) and evaluates the contents. Useful for setting options, installing personal shortcuts, etc.</td>
</tr>
<tr class="row-even"><td>-h</td>
<td>Prints a message describing the options</td>
</tr>
<tr class="row-odd"><td>-p</td>
<td>Suppresses execution of the expression snapshotAction postRead after reading a snapshot. Useful if something in the startup sequence causes the system to break.</td>
</tr>
<tr class="row-even"><td>-s</td>
<td>snapshot Reads initial world from snapshot. A snapshot begins with the line <em>exec Self -s $0 $&#64;</em> which causes the Virtual Machine to begin execution with the snapshot.</td>
</tr>
<tr class="row-odd"><td>-w</td>
<td>Don’t print warnings about object code</td>
</tr>
</tbody>
</table>
<p>These options are provided for use by Self VM implementors:</p>
<table border="1" class="docutils">
<colgroup>
<col width="3%" />
<col width="97%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>-F</td>
<td>Discards any machine code saved in the snapshot. If the code in a snapshot is for some reason corrupted, but the objects are not, this option can be used to recover the snapshot.</td>
</tr>
<tr class="row-even"><td>-l</td>
<td>logfile Writes a log of events generated by the spy to logfile.</td>
</tr>
<tr class="row-odd"><td>-r</td>
<td>Disables real timer interrupts</td>
</tr>
<tr class="row-even"><td>-t</td>
<td>Disables all timers</td>
</tr>
</tbody>
</table>
<p>Other command-line options are ignored by the Virtual Machine but are available at Self level via
the primitive <tt class="docutils literal"><span class="pre">_CommandLine</span></tt>.</p>
</div>
<div class="section" id="system-triggered-messages">
<h2>System-triggered messages<a class="headerlink" href="#system-triggered-messages" title="Permalink to this headline">¶</a></h2>
<p>Certain events cause the system to automatically send a message to the lobby. After reading a snapshot
the expression <tt class="docutils literal"><span class="pre">snapshotAction</span> <span class="pre">postRead</span></tt> is evaluated. This allows the Self world to
reinitialize itself—for example, to reopen windows.</p>
<p>There are other situations in which the system sends messages; see section 5.3.</p>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><span class="target" id="index-2"></span><span class="target" id="index-3"></span><span class="target" id="index-4"></span><span class="target" id="index-5"></span></div>
<div class="section" id="run-time-message-lookup-errors">
<span id="index-6"></span><h2>Run-time message lookup errors<a class="headerlink" href="#run-time-message-lookup-errors" title="Permalink to this headline">¶</a></h2>
<p>If an error occurs during a message send, the system sends a message to the receiver of the message.
Any object can handle these errors by defining (or inheriting) a slot with the corresponding
selector. All messages sent by the system in response to a message lookup error have the same arguments.
The first argument is the offending message’s selector; the additional arguments specify
the message send type (one of ’<tt class="docutils literal"><span class="pre">normal</span></tt>’, ’<tt class="docutils literal"><span class="pre">implicitSelf</span></tt>’, ’<tt class="docutils literal"><span class="pre">undirectedResend</span></tt>’, ’<tt class="docutils literal"><span class="pre">directedResend</span></tt>’,
or ’<tt class="docutils literal"><span class="pre">delegated</span></tt>’), the directed resend parent name or the delegatee (0 if not
applicable), the sending method holder, and a vector containing the arguments to the message, if
any.</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">undefinedSelector:Type:Delegatee:MethodHolder:Arguments</span></tt>:</dt>
<dd>The receiver does not understand the message: no slot matching the selector can be found in the receiver or its ancestors.</dd>
<dt><tt class="docutils literal"><span class="pre">ambiguousSelector:Type:Delegatee:MethodHolder:Arguments</span></tt>:</dt>
<dd>There is more than one slot matching the selector.</dd>
<dt><tt class="docutils literal"><span class="pre">missingParentSelector:Type:Delegatee:MethodHolder:Arguments</span></tt>:</dt>
<dd>The parent slot through which the resend should have been directed was not found in the sending method holder.</dd>
<dt><tt class="docutils literal"><span class="pre">mismatchedArgumentCountSelector:Type:Delegatee:MethodHolder:Arguments</span></tt>:</dt>
<dd>The number of arguments supplied to the _Perform primitive does not match the number of arguments required by the selector.</dd>
<dt><tt class="docutils literal"><span class="pre">performTypeErrorSelector:Type:Delegatee:MethodHolder:Arguments</span></tt>:</dt>
<dd>The first argument to the _Perform primitive (the selector) wasn’t a canonical string.</dd>
</dl>
</div></blockquote>
<p>These error messages are just like any other message. Therefore, it is possible that the object P
causing the error (which is being sent the appropriate error message) does not understand the error
message <em>M</em> either. If this happens, the system sends the first message (<tt class="docutils literal"><span class="pre">undefinedSelector.</span></tt>.) to
the current process, with the error message M as argument. If this is not understood, then the system
suspends the process. If the scheduler is running, it is notified of the failure.</p>
<p>The system will also suspend a process if it runs out of stack space (too much recursion) or if a
block is evaluated whose lexically-enclosing scope has already returned. Since these errors are
nonrecoverable they cannot be caught by the same Self process; the scheduler, if running, is notified.</p>
</div>
<div class="section" id="low-level-error-messages">
<h2>Low-level error messages<a class="headerlink" href="#low-level-error-messages" title="Permalink to this headline">¶</a></h2>
<p>Five kinds of errors can occur during the execution of a Self program: lookup errors, primitive errors,
programmer defined errors, non-recoverable errors, and fatal VM errors. All but the last of
these are usually caught and handled by mechanisms in the programming environment, resulting
in a debugger being presented to the user. However, if programs are run without the programming
environment, or the error-handling mechanisms themselves are broken, low-level error facilities
are used.</p>
<p>This section describes the various error messages presented by the low-level facilities. For each
category or error, the general layout of error messages in that category will be explained along with
the format of the stack trace. Then a “rogue’s gallery” of the errors in that category will be shown.</p>
<p>By default, errors are handled by a set of methods defined in module <tt class="docutils literal"><span class="pre">errorHandling</span></tt>. For all errors
except nonrecoverable and fatal VM errors, an object can handle errors in its own way by defining
its own error handling methods. If the object in which an error occurs neither inherits nor
defines error handling behavior, the VM prints out a low-level error message and a stack trace. The
system will also resort to this low-level message and trace if an error is encountered while trying
to handle an error.</p>
</div>
<div class="section" id="an-example">
<h2>An example<a class="headerlink" href="#an-example" title="Permalink to this headline">¶</a></h2>
<p>Here is an expression that produces an error in the current system:</p>
<blockquote>
<div><div class="highlight-python"><pre>“Self 7” 100000 factorial
The stack has grown too big.
(Self limits stack sizes, and cannot resume processes with stack overflows.)
To debug type “attach” or to show stack type “zombies first printError”.</pre>
</div>
</div></blockquote>
<p>The error arose because the recursive method factorial exceeded the size allocated for the process
stack which resulted in a stack overflow.</p>
<p>The virtual machine currently allocates a fixed-size stack to each process and does not extend the stack on demand.</p>
</div>
<div class="section" id="lookup-errors">
<h2>Lookup errors<a class="headerlink" href="#lookup-errors" title="Permalink to this headline">¶</a></h2>
<p>Lookup errors occur when an object does not understand a message that is sent to it. How the actual
message lookup is done is described in the Language Reference Manual.</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">No</span> <span class="pre">’foo’</span> <span class="pre">slot</span> <span class="pre">found</span> <span class="pre">in</span> <span class="pre">shell</span> <span class="pre">&lt;0&gt;.</span></tt></dt>
<dd>The lookup found no slot matching the selector <tt class="docutils literal"><span class="pre">foo</span></tt>.</dd>
</dl>
<div class="line-block">
<div class="line-block">
<div class="line"><tt class="docutils literal"><span class="pre">More</span> <span class="pre">than</span> <span class="pre">one</span> <span class="pre">’system’</span> <span class="pre">slot</span> <span class="pre">was</span> <span class="pre">found</span> <span class="pre">in</span> <span class="pre">shell</span> <span class="pre">&lt;0&gt;.</span></tt></div>
</div>
<div class="line"><tt class="docutils literal"><span class="pre">The</span> <span class="pre">matching</span> <span class="pre">slots</span> <span class="pre">are:</span> <span class="pre">oddballs</span> <span class="pre">&lt;6&gt;</span> <span class="pre">and</span> <span class="pre">prototypes</span> <span class="pre">&lt;7&gt;.</span></tt></div>
</div>
<blockquote>
<div>The lookup found two matching <tt class="docutils literal"><span class="pre">system</span></tt> slots which means the message is ambiguous. The
error message also says where the matching slots were found.    Ambiguities can often be
resolved by changing parent priorities.</div></blockquote>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">No</span> <span class="pre">’fish’</span> <span class="pre">delegatee</span> <span class="pre">slot</span> <span class="pre">was</span> <span class="pre">found</span> <span class="pre">in</span> <span class="pre">&lt;a</span> <span class="pre">child</span> <span class="pre">of</span> <span class="pre">lobby&gt;</span> <span class="pre">&lt;12&gt;.</span></tt></dt>
<dd>The lookup found no parent slot <tt class="docutils literal"><span class="pre">fish</span></tt>, which was explicitly specified as the delegatee
of the message.</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="programmer-defined-errors">
<h2>Programmer defined errors<a class="headerlink" href="#programmer-defined-errors" title="Permalink to this headline">¶</a></h2>
<p>These are explicitly raised in the Self program to report errors, e.g. sending the message <tt class="docutils literal"><span class="pre">first</span></tt>
to an empty list will cause such an error.</p>
<blockquote>
<div><div class="line-block">
<div class="line"><tt class="docutils literal"><span class="pre">Error:</span> <span class="pre">first</span> <span class="pre">is</span> <span class="pre">absent.</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">Receiver</span> <span class="pre">is:</span> <span class="pre">list</span> <span class="pre">&lt;7&gt;.</span></tt></div>
</div>
</div></blockquote>
<p>Use the selectors <tt class="docutils literal"><span class="pre">error:</span></tt> and <tt class="docutils literal"><span class="pre">error:Arguments:</span></tt> to raise a programmer defined error.</p>
</div>
<div class="section" id="primitive-errors">
<h2>Primitive errors<a class="headerlink" href="#primitive-errors" title="Permalink to this headline">¶</a></h2>
<p>Primitive failures occur when a primitive cannot perform the requested operation, for example, because
of a missing or invalid argument.</p>
<blockquote>
<div><div class="line-block">
<div class="line"><tt class="docutils literal"><span class="pre">badTypeError:</span> <span class="pre">the</span> <span class="pre">’_IntAdd:’</span> <span class="pre">primitive</span> <span class="pre">failed.</span></tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">Its</span> <span class="pre">receiver</span> <span class="pre">was</span> <span class="pre">shell</span> <span class="pre">&lt;6&gt;.</span></tt></div>
</div>
</div></blockquote>
<p>The primitive failed with <tt class="docutils literal"><span class="pre">badTypeError</span></tt> because the shell in not an integer.</p>
<blockquote>
<div><dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">The</span> <span class="pre">selector</span> <span class="pre">12</span> <span class="pre">could</span> <span class="pre">not</span> <span class="pre">be</span> <span class="pre">sent</span> <span class="pre">to</span> <span class="pre">shell</span> <span class="pre">because</span> <span class="pre">it</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">a</span> <span class="pre">string.</span></tt></dt>
<dd>The primitive <tt class="docutils literal"><span class="pre">_Perform</span></tt> expects a string as its first argument.</dd>
<dt><tt class="docutils literal"><span class="pre">The</span> <span class="pre">selector</span> <span class="pre">’add:’</span> <span class="pre">could</span> <span class="pre">not</span> <span class="pre">be</span> <span class="pre">sent</span> <span class="pre">to</span> <span class="pre">shell</span> <span class="pre">&lt;0&gt;</span> <span class="pre">because</span> <span class="pre">it</span> <span class="pre">does</span> <span class="pre">not</span> <span class="pre">take</span> <span class="pre">2</span> <span class="pre">arguments.</span></tt></dt>
<dd>The primitive <tt class="docutils literal"><span class="pre">_Perform</span></tt> received the wrong number of arguments.</dd>
</dl>
</div></blockquote>
<p>There are many other kinds of possible primitive errors.</p>
</div>
<div class="section" id="nonrecoverable-process-errors">
<h2>Nonrecoverable process errors<a class="headerlink" href="#nonrecoverable-process-errors" title="Permalink to this headline">¶</a></h2>
<p>Errors that stop a process from continuing execution are referred to as nonrecoverable errors.</p>
<blockquote>
<div><div class="line-block">
<div class="line">The stack has grown too big.</div>
<div class="line">(Self 4.0 limits stack sizes, and cannot resume processes with stack</div>
<div class="line">overflows.)</div>
</div>
<blockquote>
<div>A stack overflow error occurs because the current version of Self allocates a
fixed size stack for each process, and the stack cannot be expanded.</div></blockquote>
<div class="line-block">
<div class="line">Self 4.0 cannot run a block after its enclosing method has returned.</div>
<div class="line">(Self cannot resume this process, either.)</div>
</div>
<blockquote>
<div>This error occurs if a block is executed after its lexically enclosing method has returned.
This is called a “non-LIFO” block. Non-LIFO blocks are not supported by
the current version of Self.</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="fatal-errors">
<span id="index-7"></span><h2>Fatal errors<a class="headerlink" href="#fatal-errors" title="Permalink to this headline">¶</a></h2>
<p>In rare cases, the virtual machine may encounter a fatal error (e.g., a resource limit is exceeded or
an internal error is discovered). When this happens, a short menu is displayed:</p>
<blockquote>
<div><div class="highlight-python"><pre>VM Version: 4.0.5, Tue 27 Jun 95 13:35:49 Solaris 2.x (svr4)
Internal error: signal 11 code 3 addr 4 pc 0x1ac768.
Do you want to:
1) Quit Self (optionally attempting to write a snapshot)
2) Try to print the Self stack
3) Try to return to the Self prompt
4) Force a core dump
Your choice:</pre>
</div>
</div></blockquote>
<p>The first two lines help the Self implementors locate the problem. Printing the Self stack may
provide more information about the problem but does not always work. Returning to the Self
prompt may be successful, but the system integrity may have been compromised as a result of the
error. The safest course is to attempt to write a snapshot (if there are unsaved changes), and then
check the integrity of the snapshot by executing the primitive <tt class="docutils literal"><span class="pre">_Verify</span></tt> after starting it. If there are
any error messages from the primitive, do not attempt to continue using the snapshot.</p>
<p>Since fatal errors usually arise from a bug in the virtual machine, please send the Self group a bug
report, and include a copy of the error message if possible. If the error is reproducible please describe
how to reproduce it (including a snapshot or source files may be helpful).</p>
<span class="target" id="index-8"></span><span class="target" id="index-9"></span><span class="target" id="index-10"></span><span class="target" id="index-11"></span><span class="target" id="index-12"></span><span class="target" id="index-13"></span><span class="target" id="index-14"></span><span class="target" id="index-15"></span><span class="target" id="index-16"></span><span class="target" id="index-17"></span><span class="target" id="index-18"></span><span class="target" id="index-19"></span><span class="target" id="index-20"></span><span class="target" id="index-21"></span><span class="target" id="index-22"></span><span class="target" id="index-23"></span><span class="target" id="index-24"></span><span class="target" id="index-25"></span><span class="target" id="index-26"></span><span class="target" id="index-27"></span><span class="target" id="index-28"></span><span class="target" id="index-29"></span><span class="target" id="index-30"></span><span class="target" id="index-31"></span></div>
<div class="section" id="the-initial-self-world">
<span id="index-32"></span><h2>The initial Self world<a class="headerlink" href="#the-initial-self-world" title="Permalink to this headline">¶</a></h2>
<p>The diagram on the following pages shows all objects in the “bare” Self world. In addition, literals
like integers, floats, and strings are conceptually part of the initial Self world; block and object
literals are created by the programmer as needed. All the objects in the system are created by adding
slots to these objects or by cloning them. Table 1 lists all the initial objects and provides a short
description for each. Reading in the world rearranges the structure of the “bare” Self world (see
The Self World)</p>
<div class="figure align-left">
<a class="reference internal image-reference" href="_images/Chapter_5_Figure_3.png"><img alt="_images/Chapter_5_Figure_3.png" src="_images/Chapter_5_Figure_3.png" style="width: 680.0px; height: 882.0px;" /></a>
<p class="caption">Figure 3: The initial Self world (part 1)</p>
</div>
<div class="figure align-left">
<a class="reference internal image-reference" href="_images/Chapter_5_Figure_4.png"><img alt="_images/Chapter_5_Figure_4.png" src="_images/Chapter_5_Figure_4.png" style="width: 695.0px; height: 451.0px;" /></a>
<p class="caption">Figure 4: The initial Self world (part 2)</p>
</div>
<p id="index-33"><strong>Table 1 Objects in the initial Self world</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Object</td>
<td>Description</td>
</tr>
<tr class="row-even"><td>lobby</td>
<td>The center of the Self object hierarchy, and the context in which expressions typed in at the VM prompt, read in via _RunScript, or used as the initializers of slots, are evaluated.</td>
</tr>
</tbody>
</table>
<p><em>Objects in the lobby</em></p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>shell</td>
<td>After reading in the world, shell is the context in which expressions typed in at the prompt are evaluated.</td>
</tr>
<tr class="row-even"><td>snapshotAction</td>
<td>An object with slot for the startup action (see section 5.2), postRead. This slot initially contains nil.</td>
</tr>
<tr class="row-odd"><td>systemObjects</td>
<td>This object contains slots containing the general system objects, including nil, true, false, and the prototypical vectors and mirrors.</td>
</tr>
</tbody>
</table>
<p><em>Objects in systemObjects</em></p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>nil</td>
<td>The initializer for slots that are not explicitly initialized. Indicates “not a useful object.”</td>
</tr>
<tr class="row-even"><td>true</td>
<td>Boolean true. Argument to and returned by some primitives.</td>
</tr>
<tr class="row-odd"><td>false</td>
<td>Boolean false. Argument to and returned by some primitives.</td>
</tr>
<tr class="row-even"><td>vector</td>
<td>The prototype for (normal) vectors.</td>
</tr>
<tr class="row-odd"><td>byteVector</td>
<td>The prototype for byte vectors.</td>
</tr>
<tr class="row-even"><td>proxy</td>
<td>The prototype for proxy objects.</td>
</tr>
<tr class="row-odd"><td>fctProxy</td>
<td>The prototype for fctProxy objects.</td>
</tr>
<tr class="row-even"><td>vector parent</td>
<td>The object that vector inherits from. Since all object vectors will inherit from this object (because they are cloned from vector), this object will be the repository for shared behavior (a traits object) for vectors.</td>
</tr>
<tr class="row-odd"><td>byteVector parent</td>
<td>Similar to vector parent: the byteVector traits object.</td>
</tr>
<tr class="row-even"><td>slotAnnotation</td>
<td>The default slot annotation object.</td>
</tr>
<tr class="row-odd"><td>objectAnnotation</td>
<td>The default object annotation object</td>
</tr>
<tr class="row-even"><td>profiler</td>
<td>The prototype for profilers.</td>
</tr>
<tr class="row-odd"><td>mirrors</td>
<td>See below.</td>
</tr>
</tbody>
</table>
<p id="index-34"><em>Literals and their parents</em></p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>integers</td>
<td>Integers have one slot, a parent slot called parent. All integers have the same parent: see 0 parent, below.</td>
</tr>
<tr class="row-even"><td>0 parent</td>
<td>All integers share this parent, the integer traits object.</td>
</tr>
<tr class="row-odd"><td>floats</td>
<td>Floats have one slot, a parent slot called parent. All floats have the same parent: see 0.0 parent, below.</td>
</tr>
<tr class="row-even"><td>0.0 parent</td>
<td>All floats share this parent, the float traits object.</td>
</tr>
<tr class="row-odd"><td>canonical strings</td>
<td>In addition to a byte vector part, a canonical string has one slot, parent, a parent slot containing the same object for all canonical strings (see ’’parent below).</td>
</tr>
<tr class="row-even"><td>&#8216;&#8217;parent</td>
<td>All canonical strings share this parent, the string traits object.</td>
</tr>
<tr class="row-odd"><td>blocks</td>
<td>Blocks have two slots: parent, a parent slot containing the same object for all blocks (see [] parent, below), and value (or value:, or value:With:, etc., depending on the number of arguments the block takes) which contains the block’s deferred method.</td>
</tr>
<tr class="row-even"><td>[ ] parent</td>
<td>All blocks share this parent, the block traits object.</td>
</tr>
</tbody>
</table>
<span class="target" id="index-35"></span><span class="target" id="index-36"></span><span class="target" id="index-37"></span><span class="target" id="index-38"></span><span class="target" id="index-39"></span><p id="index-40">Prototypical mirrors</p>
<p>All of the prototypical mirrors consist of one slot, a parent slot named parent. Each of
these parent slots points to an empty object (denoted in Figure 5 by “( )”).</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>smiMirror</td>
<td>Prototypical mirror on a small integer; the reflectee is 0.</td>
</tr>
<tr class="row-even"><td>floatMirror</td>
<td>Prototypical mirror on a float; the reflectee is 0.0.</td>
</tr>
<tr class="row-odd"><td>stringMirror</td>
<td>Prototypical mirror on a canonical string; the reflectee is the empty canonical string (’’).</td>
</tr>
<tr class="row-even"><td>processMirror</td>
<td>Prototypical mirror on a process; the reflectee is the initial process.</td>
</tr>
<tr class="row-odd"><td>byteVectorMirror</td>
<td>Prototypical mirror on a byte vector; the reflectee is the prototypical byte vector.</td>
</tr>
<tr class="row-even"><td>objVectorMirror</td>
<td>Prototypical mirror on object vectors; the reflectee is the prototypical object vector.</td>
</tr>
<tr class="row-odd"><td>assignmentMirror</td>
<td>Mirror on the assignment primitive; the actual reflectee is an empty object.</td>
</tr>
<tr class="row-even"><td>mirrorMirror</td>
<td>Prototypical mirror on a mirror; the reflectee is slotsMirror.</td>
</tr>
<tr class="row-odd"><td>slotsMirror</td>
<td>Prototypical mirror on a plain object without code; the reflectee is an empty object.</td>
</tr>
<tr class="row-even"><td>blockMirror</td>
<td>Prototypical mirror on a block.</td>
</tr>
<tr class="row-odd"><td>methodMirror</td>
<td>Prototypical mirror on a normal method.</td>
</tr>
<tr class="row-even"><td>blockMethodMirror</td>
<td>Prototypical mirror on a block method.</td>
</tr>
<tr class="row-odd"><td>methodActivationMirror</td>
<td>Prototypical mirror on a method activation.</td>
</tr>
<tr class="row-even"><td>blockMethodActivationMirror</td>
<td>Prototypical mirror on a block activation.</td>
</tr>
<tr class="row-odd"><td>proxyMirror</td>
<td>Prototypical mirror on a proxy.</td>
</tr>
<tr class="row-even"><td>fctProxyMirror</td>
<td>Prototypical mirror on a fctProxy.</td>
</tr>
<tr class="row-odd"><td>profilerMirror</td>
<td>Prototypical mirror on a profiler.</td>
</tr>
</tbody>
</table>
<span class="target" id="index-41"></span><span class="target" id="index-42"></span></div>
<div class="section" id="option-primitives">
<span id="index-43"></span><h2>Option Primitives<a class="headerlink" href="#option-primitives" title="Permalink to this headline">¶</a></h2>
<p><strong>This section has not been updated to include all options present in Self 4.0.</strong></p>
<p>Option primitives control various aspects of the Self system and its inner workings. Many of
them are used to debug or instrument the Self system and are probably of little interest to users.
The options most useful for users are listed in Table 2; other option primitives can be found in Appendix
5.B, and a list of all option primitives and their current settings can be printed with the
primitive <tt class="docutils literal"><span class="pre">_PrintOptionPrimitives.</span></tt></p>
<span class="target" id="index-44"></span><span class="target" id="index-45"></span><span class="target" id="index-46"></span><p id="index-47"><strong>Table 2 Some useful option primitives</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>_PrintPeriod[:] <a class="footnote-reference" href="#f1" id="id1">[1]</a></td>
<td>Print a period when reading a script file with _RunScript. Default: false.</td>
</tr>
<tr class="row-odd"><td>_PrintScriptName[:]</td>
<td>Print the file name when reading a script file. Default: false.</td>
</tr>
<tr class="row-even"><td>_Spy[:]</td>
<td>Start the system monitor (see Appendix 5.A for details). Default: false.</td>
</tr>
<tr class="row-odd"><td>_StackPrintLimit[:]</td>
<td>Controls the number of stack frames printed by _PrintProcessStack. Default:20.</td>
</tr>
<tr class="row-even"><td>_DirPath[:]</td>
<td>The default directory path for script files.</td>
</tr>
</tbody>
</table>
<p>Each option primitive controls a variable within the virtual machine containing a boolean, integer,
or string (in fact, the option primitives can be thought of as “primitive variables”). Invoking the
version of the primitive that doesn’t take an argument returns the current setting; invoking it with
an argument sets the variable to the new value and returns the old value.</p>
<p>Try running the system monitor with <em>_Spy: true</em>. The system monitor will continuously display
various information about the system’s activities and your memory usage.</p>
<span class="target" id="index-48"></span><span class="target" id="index-49"></span><span class="target" id="index-50"></span><span class="target" id="index-51"></span><span class="target" id="index-52"></span><span class="target" id="index-53"></span><span class="target" id="index-54"></span><span class="target" id="index-55"></span></div>
<div class="section" id="interfacing-with-other-languages">
<span id="index-56"></span><h2>Interfacing with other languages<a class="headerlink" href="#interfacing-with-other-languages" title="Permalink to this headline">¶</a></h2>
<p>This chapter describes how to access objects and call routines that are written in other languages
than Self. We will refer to such entities as <em>foreign objects</em> and <em>foreign routines</em>. A typical use
would be to make a function found in a C library accessible in Self. Three steps are necessary to
accomplish this:</p>
<blockquote>
<div><ul class="simple">
<li>Write and compile a piece of “glue” code that specifies argument and result types for the foreign routine and how to convert between these types and Self objects.</li>
<li>Link the resulting object code to the Self virtual machine.</li>
<li>Create a function proxy object (actually a foreignFct object) that represents the routine in the Self world.</li>
</ul>
</div></blockquote>
<p>Each of these steps is described in detail in the following sections.</p>
<span class="target" id="index-57"></span><span class="target" id="index-58"></span><div class="section" id="proxy-and-fctproxy-objects">
<span id="index-59"></span><h3>Proxy and fctProxy objects<a class="headerlink" href="#proxy-and-fctproxy-objects" title="Permalink to this headline">¶</a></h3>
<p>A foreign object is represented by a proxy object in the Self world. A <em>proxy</em> object is an object
that encapsulates a pointer to the foreign object it represents. In addition to the pointer to the foreign
object, the proxy object contains a type seal. A type seal is an immutable value that is assigned
to the proxy object, when it is created. The <em>type seal</em> is intended to capture type information about
the pointer encapsulated in the proxy. For example, proxies representing window objects should
have a different type seal than proxies representing event objects. By checking the type seal against
an expected value whenever a proxy is “opened”, many type errors can be caught. The last property
of proxy objects is that they can be <em>dead</em> or <em>live</em>. If an attempt is made to use the pointer in a dead
proxy object, an error results (<tt class="docutils literal"><span class="pre">deadProxyError</span></tt>). Proxy objects may be explicitly killed, by
sending the primitive message <tt class="docutils literal"><span class="pre">_Kill</span></tt> to them. Furthermore, they are automatically killed after
reading in a snapshot. This way problems with dangling references to foreign objects that were not
included in the snapshot are avoided.</p>
<p><em>FctProxy</em> objects are similar to proxy objects: they have a type seal and are either live or dead.
However, they represent a foreign routine, rather than a foreign object. A foreign routine can be invoked
by sending the primitive messages <tt class="docutils literal"><span class="pre">_Call</span></tt>, <tt class="docutils literal"><span class="pre">_Call:{With:}</span></tt>,
<tt class="docutils literal"><span class="pre">_CallAndConvert{With:And:}</span></tt> to the <tt class="docutils literal"><span class="pre">fctProxy</span></tt> representing it. Note that <tt class="docutils literal"><span class="pre">fctProxy</span></tt> objects
are low-level. Most, if not all, uses of foreign routines should use the interface provided by <tt class="docutils literal"><span class="pre">foreignFct</span></tt>
objects.</p>
<p>Proxies (and <tt class="docutils literal"><span class="pre">fctProxies</span></tt>) can be freely cloned. However a cloned proxy will be dead. A dead
proxy is revived when it is used by a foreign function to, e.g., return a pointer. The return value of
the foreign function together with a type seal is stored into the dead proxy, which is then revived
and returned as the result of the foreign routine call. The motivation for this somewhat complicated
approach is that there will be several different kinds of proxies in a typical Self system. Different
kinds of proxies may have different slots added, so rather than having the foreign routine figure out
which kind of proxy to clone for the result, the Self code calling the foreign routine must construct
and pass down an “empty” (dead) proxy to hold the result. This proxy is called a <em>result proxy</em>
and it is the last argument supplied to the foreign function.</p>
<span class="target" id="index-60"></span><span class="target" id="index-61"></span></div>
<div class="section" id="glue-code">
<span id="index-62"></span><h3>Glue code<a class="headerlink" href="#glue-code" title="Permalink to this headline">¶</a></h3>
<p>Glue code is responsible for the transition from Self to foreign routines. It forms wrappers around
foreign routines. There is one wrapper per foreign routine. A wrapper takes a number of arguments
of type <tt class="docutils literal"><span class="pre">oop</span></tt>, and returns an <tt class="docutils literal"><span class="pre">oop</span></tt> (<tt class="docutils literal"><span class="pre">oop</span></tt> is the C++ type for “reference to Self object”). When a
wrapper is executed, it performs the following steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Check that the arguments supplied have the correct types.</li>
<li>Convert the arguments from Self representation to the representation that the foreign routine needs.</li>
<li>Invoke the foreign routine on the converted arguments.</li>
<li>Convert the return value of the foreign routine to a Self object and return this as the Self level result.</li>
</ol>
</div></blockquote>
<p>To make it easier to write glue code, a special purpose language has been designed for this. The
result is that glue for a foreign routine will often consist of only a single line. The glue language is
implemented as a set of C++ preprocessor macros. Therefore, glue code is just a (rather peculiar)
kind of C++. Glue code can be in a file of its own, or – if it is glue for calling C++ routines – it can
be in the same file as the foreign routines, and compiled with them.</p>
<p>To make the definition of the glue language available, the file containing glue code must contain:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="c"># include &quot;_glueDefs.c.incl&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p>The file “_glueDefs.c.incl” includes a bunch of C++ header files that contain all the definitions
necessary for the glue. Of the included files, “glueDefs.h” is probably the most interesting in this
context. It defines the glue language and also contains some comments explaining it.</p>
<p>Since different foreign languages have different type systems and calling conventions the glue language
is actually not a single language, but one for each supported foreign language. Presently C
and C++ are supported. Section 5.13.5 describes C glue and section 5.13.9 describes C++ glue.</p>
<span class="target" id="index-63"></span><span class="target" id="index-64"></span></div>
<div class="section" id="compiling-and-linking-glue-code">
<span id="index-65"></span><h3>Compiling and linking glue code<a class="headerlink" href="#compiling-and-linking-glue-code" title="Permalink to this headline">¶</a></h3>
<p>Since glue code is a special form of C++ code, a C++ compiler is needed to translate it. The way
this is done may depend on the computer system and the available C++ compiler. The following
description applies to Sun SPARCstations using the GNU g++ compiler.</p>
<p>A specific example of how to compile glue code can be found in the directory containing the <em>toself</em>
demo (see section 5.13.16 for further details). The makefile in that directory describes how to
translate a <tt class="docutils literal"><span class="pre">.c</span></tt> file containing glue into something that can be invoked from Self. This is a two
stage process: first the <tt class="docutils literal"><span class="pre">.c</span></tt> file is compiled into a <tt class="docutils literal"><span class="pre">.o</span></tt> file which is then linked (perhaps with other
<tt class="docutils literal"><span class="pre">.o</span></tt> files and libraries that the glue code depends on)† into a <tt class="docutils literal"><span class="pre">.so</span></tt> file (a so-called dynamic library).
While the compilation is straightforward, several issues concerning the linking must be explained.</p>
<dl class="docutils">
<dt><strong>Linking.</strong></dt>
<dd>Before a foreign routine can be called it must be linked to the Self virtual machine. The
linking can be done either statically, i.e. before Self is started, or dynamically, i.e. while Self is
running. The Self system employs both dynamic and static linking, but users should only use dynamic
linking, as static linking requires more understanding of the structure of the Virtual Machine.
The choice between dynamic and static linking involves a trade-off between safety and
flexibility as outlined in the following.</dd>
<dt><strong>Dynamic linking</strong></dt>
<dd>Dynamic linking has the advantage that it is done on demand, so only foreign routines that are actually
used in a particular session will be loaded and take up space. Debugging foreign routines is
also easier, especially if the dynamic linker supports unlinking. The main disadvantages with dynamic
linking is that more things can go wrong at run time. For example, if an object file containing
a foreign routine can not be found, a run time error occurs. The Sun OS dynamic linker, ld.so,
only handles dynamic libraries which explains why the second stage of glue translation is necessary.</dd>
<dt><strong>Static linking</strong></dt>
<dd>Static linking, the alternative that was not chosen for Self, has the advantage that it needs to be
done only once. The statically linked-in files will then be available for ever after. The main disadvantages
are that the linked-in files will always take up space whether used or not in a given Self
session, that the VM must be completely relinked every time new code is added, and that debugging
is harder because there is no way to unlink code with bugs in. For these reasons the following
examples all use dynamic linking.</dd>
</dl>
</div>
<div class="section" id="a-simple-glue-example-calling-a-c-function">
<span id="index-66"></span><h3>A simple glue example: calling a C function<a class="headerlink" href="#a-simple-glue-example-calling-a-c-function" title="Permalink to this headline">¶</a></h3>
<p>Suppose we have a C function that encrypts text strings in some fancy way. It takes two arguments,
a string to encrypt and a key, and returns a string which is the result of the encryption. To use this
function from Self, we write a line of C glue. Here is the entire file, “encrypt.c”, containing both
the encryption function and the glue:†</p>
<blockquote>
<div><div class="highlight-python"><pre>/* Make glue available by including it. */
# include "incls/_glueDefs.c.incl"
/* Naive encryption function. */
char *encrypt(char *str, int key) {
        static char res[1000];
        int i;
        for (i = 0; str[i]; ++i)
                res[i] = str[i] + key;
        res[i] = ’\0’;
        return res;
}

/* Make glue expand to full functions, not just prototypes. */
# define WHAT_GLUE FUNCTIONS
        C_func_2(string,, encrypt, encrypt_glue,, string,, int,)
# undef WHAT_GLUE</pre>
</div>
</div></blockquote>
<p>A few words of explanation: the last three lines of this file contain the glue code. First defining
<tt class="docutils literal"><span class="pre">WHAT_GLUE</span></tt> to be <tt class="docutils literal"><span class="pre">FUNCTIONS</span></tt>, makes the following line expand into a full wrapper function (defining
<tt class="docutils literal"><span class="pre">WHAT_GLUE</span></tt> to be <tt class="docutils literal"><span class="pre">PROTOTYPES</span></tt> instead, will cause the <tt class="docutils literal"><span class="pre">C_func_2</span></tt> line to produce a function
prototype only). The line containing the macro <tt class="docutils literal"><span class="pre">C_func_2</span></tt> is the actual wrapper for <tt class="docutils literal"><span class="pre">encrypt</span></tt>.
The “2” designates that <tt class="docutils literal"><span class="pre">encrypt</span></tt> takes 2 arguments. The meaning of the arguments, from left to
right are:</p>
<blockquote>
<div><ul class="simple">
<li>“string,”: specifies that encrypt returns a string argument.</li>
<li>“encrypt”: name of function we are constructing wrapper for.</li>
<li>“encrypt_glue”: name that we want the wrapper function to have.</li>
<li>An empty argument signifying that encrypt is not to be passed a failure handle (explained later).</li>
<li>“string,”: specifies that the first argument to encrypt is a string.</li>
<li>“int,”: specifies that the second argument to encrypt is an int.</li>
</ul>
</div></blockquote>
<p>Having written this file, we now prepare a makefile to compile and link it. To do this, we can extend
the makefile in <tt class="docutils literal"><span class="pre">objects/glue/{sun4,svr4}</span></tt> (depending on OS in use) and then run make.
This results in the shared library file <tt class="docutils literal"><span class="pre">encrypt.so</span></tt>. Finally, to try it out, we can type these commands
(at the Self prompt or in the UI):</p>
<blockquote>
<div><div class="highlight-python"><pre>&gt; _AddSlotsIfAbsent: ( | encrypt | )
lobby

&gt; encrypt: ( foreignFct copyName: ’encrypt_glue’ Path: ’encrypt.so’ )
lobby

&gt; encrypt
&lt;C++ function(encrypt_glue)&gt;

&gt; encrypt value: ’Hello Self’ With: 3
’Khoor#Vhoi’

&gt; encrypt value: ’Khoor#Vhoi’ With: -3
’Hello Self’</pre>
</div>
</div></blockquote>
<p>Comparing the signature for the function encrypt with the arguments to the <tt class="docutils literal"><span class="pre">C_func_2</span></tt> macro it
is clear that there is a straightforward mapping between the two. One day we hope to find the time
to write a Self program that can parse a C or C++ header file and generate glue code corresponding
to the definitions in it. In the meantime, glue code must be handwritten.</p>
<span class="target" id="index-67"></span></div>
<div class="section" id="c-glue">
<span id="index-68"></span><h3>C glue<a class="headerlink" href="#c-glue" title="Permalink to this headline">¶</a></h3>
<p>C glue supports accessing C functions and data from Self. There are three main parts of C glue:</p>
<blockquote>
<div><ul class="simple">
<li>Calling functions.</li>
<li>Reading/assigning global variables.</li>
<li>Reading/assigning a component in a struct that is represented by a proxy object in Self.</li>
</ul>
</div></blockquote>
<p>In addition, C++ glue for creating objects can be used to create C structs (see section 5.13.9). The
following sections describe each of these parts of C glue.</p>
<span class="target" id="index-69"></span><span class="target" id="index-70"></span></div>
<div class="section" id="calling-c-functions">
<span id="index-71"></span><h3>Calling C functions<a class="headerlink" href="#calling-c-functions" title="Permalink to this headline">¶</a></h3>
<p>The macro <tt class="docutils literal"><span class="pre">C_func_N</span></tt> where N is 0, 1, 2, ... is used to “glue in” a C function. The number N denotes
the number of arguments that should be given <em>at the Self level</em>, when calling the function. This
number may be different from the number of arguments that the C function takes since, e.g., some
argument conversions (see below) produce two C arguments from one Self object. Here is the
general syntax for <tt class="docutils literal"><span class="pre">C_func_N</span></tt>:</p>
<blockquote>
<div><div class="highlight-python"><pre>C_func_N(res_cnv,res_aux, fexp, gfname, fail_opt, c0,a0, ... cN,aN)</pre>
</div>
</div></blockquote>
<p>Compare this with the glue that was used in the encrypt example in section 5.13.4:</p>
<blockquote>
<div><div class="highlight-python"><pre>C_func_2(string,, encrypt, encrypt_glue,, string,, int,)</pre>
</div>
</div></blockquote>
<p>The meaning of each argument to <tt class="docutils literal"><span class="pre">C_func_N</span></tt> is as follows:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">res_cnv,res_aux</span></tt>: these two arguments form a “conversion pair” that specifies how the result that the function returns is converted to a Self object. In the <tt class="docutils literal"><span class="pre">encrypt</span></tt> example, where the function returns a null terminated string, <tt class="docutils literal"><span class="pre">res_cnv</span></tt> has the value <tt class="docutils literal"><span class="pre">string</span></tt>, and <tt class="docutils literal"><span class="pre">res_aux</span></tt> is empty. Table 3 lists all the possible values for the <tt class="docutils literal"><span class="pre">res_cnv,res_aux</span> <span class="pre">pair</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">fexp</span></tt> is a C expression which evaluates to the function that is being glued in. In the simplest case, such as in the <tt class="docutils literal"><span class="pre">encrypt</span></tt> example, the expression is the name of a function, but in general it may be any C expression, involving function pointers etc., which in a global context evaluates to a function.</li>
<li><tt class="docutils literal"><span class="pre">gfname</span></tt>: the name of the function which the <tt class="docutils literal"><span class="pre">C_func_N</span></tt> macro expands into. In the <tt class="docutils literal"><span class="pre">encrypt</span></tt> example, the convention of appending <tt class="docutils literal"><span class="pre">_glue</span></tt> to the C function’s name was used. When accessing a glued-in function from Self, the value of <tt class="docutils literal"><span class="pre">gfname</span></tt> is the name that must be used.</li>
<li><tt class="docutils literal"><span class="pre">fail_opt</span></tt>: there are two possible values for this argument. It can be empty (as in the example) or it can be <tt class="docutils literal"><span class="pre">fail</span></tt>. In the latter case, the C function being called is passed an additional argument that will be the last argument and have type <tt class="docutils literal"><span class="pre">“void</span> <span class="pre">*”</span></tt>. Using this argument, the C function may abort its execution and raise an exception. The result is that the “IfFail block” in Self will be invoked.</li>
<li><tt class="docutils literal"><span class="pre">ci,ai</span></tt>: each of these pairs describes how to convert a Self level argument to one or more C level arguments.† For example, in the glue for <tt class="docutils literal"><span class="pre">encrypt</span></tt>, <tt class="docutils literal"><span class="pre">c0</span></tt>,``a0`` specifies that the first argument to <tt class="docutils literal"><span class="pre">encrypt</span></tt> is a string. Likewise <tt class="docutils literal"><span class="pre">c1</span></tt>,``a1`` specifies that the second argument is an integer. Note that in both these cases, the a-part of the conversion is empty. Table 3 lists all the possible values for the <tt class="docutils literal"><span class="pre">ci</span></tt>,``ai`` pair.</li>
</ul>
</div></blockquote>
<p><em>Handling failures</em>. Here is a slight modification of the encryption example to illustrate how the C function can raise an exception that causes the “IfFail block” to be invoked at the Self level:</p>
<blockquote>
<div><div class="highlight-python"><pre>/* Make glue available by including it. */
# include "incls/_glueDefs.c.incl"
/* Naive encryption function. */
char *encrypt(char *str, int key, void *FH) {
        static char res[1000];
        int i;
        if (key == 0) {
                failure(FH, "key == 0 is identity map");
                return NULL;
        }
        for (i = 0; str[i]; i++)
                res[i] = str[i] + key;
        res[i] = ’\0’;
        return res;
}
/* Make glue expand to full functions, not just prototypes. */
# define WHAT_GLUE FUNCTIONS
        C_func_2(string,, encrypt, encrypt_glue, fail, string,, int,)
# undef WHAT_GLUE</pre>
</div>
</div></blockquote>
<p>Observe that the <tt class="docutils literal"><span class="pre">fail_opt</span></tt> argument now has the value <tt class="docutils literal"><span class="pre">fail</span></tt> and that the <tt class="docutils literal"><span class="pre">encrypt</span></tt> function
raises an exception, using <tt class="docutils literal"><span class="pre">failure</span></tt>, if the key is 0. There are two ways to raise exceptions:</p>
<blockquote>
<div><div class="highlight-python"><pre>extern "C" void failure(void *FH, char *msg);
extern "C" void unix_failure(void *FH, int err = -1);</pre>
</div>
</div></blockquote>
<p>In both cases, the <tt class="docutils literal"><span class="pre">FH</span></tt> argument is the “failure handle” that was passed by the <tt class="docutils literal"><span class="pre">C_func_N</span></tt> macro.
The second argument to <tt class="docutils literal"><span class="pre">failure</span></tt> is a string. It will be passed to the “IfFail block” in Self.
<tt class="docutils literal"><span class="pre">unix_failure</span></tt> takes an optional integer as its second argument. If this integer has the value -1,
or is missing, the value of <tt class="docutils literal"><span class="pre">errno</span></tt> is used instead. The integer is interpreted as a UNIX error number,
from which a corresponding string is constructed. The string is then, as for <tt class="docutils literal"><span class="pre">failure</span></tt>, passed
to the “IfFail block” at the call site in Self.</p>
<blockquote>
<div><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">After calling <tt class="docutils literal"><span class="pre">failure</span></tt> or <tt class="docutils literal"><span class="pre">unix_failure</span></tt> a normal <tt class="docutils literal"><span class="pre">return</span></tt> must be done. The value returned (in the example <tt class="docutils literal"><span class="pre">NULL</span></tt>) is ignored.</p>
</div>
</div></blockquote>
<span class="target" id="index-72"></span></div>
<div class="section" id="reading-and-assigning-global-variables">
<span id="index-73"></span><h3>Reading and assigning global variables<a class="headerlink" href="#reading-and-assigning-global-variables" title="Permalink to this headline">¶</a></h3>
<p>Reading the value of a global variable is done using the <tt class="docutils literal"><span class="pre">C_get_var</span></tt> macro. Assigning a value to
a global variable is done using <tt class="docutils literal"><span class="pre">C_set_var</span></tt>. Both macros expand into a C++ function that converts
between Self and C representation, and reads or assigns the variable. Here is the general syntax:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">C_get_var</span><span class="p">(</span><span class="n">cnvt_res</span><span class="p">,</span><span class="n">aux_res</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">gfname</span><span class="p">)</span>
<span class="n">C_set_var</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">expr_c0</span><span class="p">,</span><span class="n">expr_a0</span><span class="p">,</span> <span class="n">gfname</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>A concrete example is reading the value of the variable <tt class="docutils literal"><span class="pre">errno</span></tt>, which can be done using:</p>
<blockquote>
<div><div class="highlight-python"><pre>C_get_var(int,, errno, get_errno_glue)</pre>
</div>
</div></blockquote>
<p>The meaning of the each argument is:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">cnvt_res</span></tt>,``aux_res``: how to convert the value of the global variable that is being read to a Self object. In the <tt class="docutils literal"><span class="pre">errno</span></tt> example, <tt class="docutils literal"><span class="pre">cnvt_res</span></tt> is <tt class="docutils literal"><span class="pre">int</span></tt> and <tt class="docutils literal"><span class="pre">aux_res</span></tt> is empty, since the type of <tt class="docutils literal"><span class="pre">errno</span></tt> is <tt class="docutils literal"><span class="pre">int</span></tt>. The <tt class="docutils literal"><span class="pre">cnvt_res</span></tt>,``aux_res`` can be any one of the result conversions found in Table 3.</li>
<li><tt class="docutils literal"><span class="pre">expr</span></tt> is the variable whose value is being read. In the <tt class="docutils literal"><span class="pre">errno</span></tt> example, it is simply <tt class="docutils literal"><span class="pre">errno</span></tt>, but in general, it may actually be any expression that is valid in a global context, even an expression involving function calls.</li>
<li><tt class="docutils literal"><span class="pre">gfname</span></tt>: the name of the C++ function that <tt class="docutils literal"><span class="pre">C_get_var</span></tt> or <tt class="docutils literal"><span class="pre">C_set_var</span></tt> expands into.</li>
<li><tt class="docutils literal"><span class="pre">var</span></tt> is the name of a global variable that a value is assigned to. In general, <tt class="docutils literal"><span class="pre">var</span></tt>, may be any expression that in a global context evaluates to an l-value.</li>
<li><tt class="docutils literal"><span class="pre">expr_c0</span></tt>,``expr_a0``: when assigning to a variable, the value it is assigned is obtained by converting a Self object to a C value. The <tt class="docutils literal"><span class="pre">expr_c0</span></tt>,``expr_a0`` pair, which can be any one of the argument conversions listed in Table 3, specifies how to do this conversion.</li>
</ul>
</div></blockquote>
<span class="target" id="index-74"></span><span class="target" id="index-75"></span></div>
<div class="section" id="reading-and-assigning-struct-components">
<span id="index-76"></span><h3>Reading and assigning struct components<a class="headerlink" href="#reading-and-assigning-struct-components" title="Permalink to this headline">¶</a></h3>
<p>Reading the value of a struct component or assigning a value to it is similar to doing the same operations
on a global variable. The difference is that the struct must somehow be specified. This is
taken care of by the macros <tt class="docutils literal"><span class="pre">C_get_comp</span></tt> and <tt class="docutils literal"><span class="pre">C_set_comp</span></tt>. The general syntax is:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">C_get_comp</span><span class="p">(</span><span class="n">cnvt_res</span><span class="p">,</span><span class="n">aux_res</span><span class="p">,</span> <span class="n">cnvt_strc</span><span class="p">,</span><span class="n">aux_strc</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">gfname</span><span class="p">)</span>
<span class="n">C_set_comp</span><span class="p">(</span><span class="n">cnvt_strc</span><span class="p">,</span><span class="n">aux_strc</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">expr_c0</span><span class="p">,</span><span class="n">expr_a0</span><span class="p">,</span> <span class="n">gfname</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Here is an example, assigning to the sin_port field of a struct sockaddr_in (this struct is defined
in /usr/include/netinet/in.h):</p>
<blockquote>
<div><div class="highlight-python"><pre>struct sockaddr_in {
        short                   sin_family;
        u_short                 sin_port;
        struct in_addr          sin_addr;
        char                    sin_zero[8];
};</pre>
</div>
</div></blockquote>
<p>The struct is represented by a proxy object:</p>
<blockquote>
<div><div class="highlight-python"><pre>char *socks = "type seal for sockaddr_in proxies";
C_set_comp(proxy,(sockaddr_in *,socks), .sin_port, short,,set_sin_port_glue)</pre>
</div>
</div></blockquote>
<p>The <tt class="docutils literal"><span class="pre">sockaddr_in</span></tt> example defines a function, <tt class="docutils literal"><span class="pre">set_sin_port_glue</span></tt>, which can be called from
Self. The function takes two arguments, the first being a proxy representing a <tt class="docutils literal"><span class="pre">sockaddr_in</span></tt>
struct, the second being a short integer. After converting types, <tt class="docutils literal"><span class="pre">set_sin_port_glue</span></tt> performs
the assignment</p>
<blockquote>
<div><div class="highlight-python"><pre>(*first_converted_arg).sin_port = second_converted_arg.</pre>
</div>
</div></blockquote>
<p>In general the meaning of the <tt class="docutils literal"><span class="pre">C_get_comp</span></tt> and <tt class="docutils literal"><span class="pre">C_set_comp</span></tt> arguments is:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">cnvt_res</span></tt>, <tt class="docutils literal"><span class="pre">aux_res</span></tt>: how to convert the value of the component that is being read to a
Self object. Any of the result conversions found in Table 3 may be applied.</li>
<li><tt class="docutils literal"><span class="pre">cnvt_strc</span></tt>, <tt class="docutils literal"><span class="pre">aux_strc</span></tt>: the conversion that is applied to produce a struct upon which the
operation is performed. In the <tt class="docutils literal"><span class="pre">sin_port</span></tt> example, this conversion is a proxy conversion,
implying that in Self, the struct whose <tt class="docutils literal"><span class="pre">sin_port</span></tt> component is assigned is represented by
a proxy object. In general, any of the argument conversions from Table 3 that results in a
pointer, may be used.</li>
<li><tt class="docutils literal"><span class="pre">comp</span></tt> is the name of the component to be read or assigned. In the sin_port example, this
name is <tt class="docutils literal"><span class="pre">“.sin_port”</span></tt>. Note that it includes a “.”. This, e.g., allows handling pointers to
int’s by pretending that it is a pointer to a struct and operating on a component with an
empty name.</li>
<li><tt class="docutils literal"><span class="pre">gfname</span></tt>: the name of the C++ function that <tt class="docutils literal"><span class="pre">C_get_comp</span></tt> or <tt class="docutils literal"><span class="pre">C_set_comp</span></tt> expands into.</li>
<li><tt class="docutils literal"><span class="pre">expr_co</span></tt>, <tt class="docutils literal"><span class="pre">expr_a0</span></tt>: when assigning to a component, the value it is assigned is obtained by
converting a Self object to a C value. The <tt class="docutils literal"><span class="pre">expr_co</span></tt>, <tt class="docutils literal"><span class="pre">expr_a0</span></tt> pair, which can be any one
of the argument conversions listed in Table 3, specifies how to do this conversion.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="index-77">
<span id="id2"></span><h3>C++ glue<a class="headerlink" href="#index-77" title="Permalink to this headline">¶</a></h3>
<p>Since C++ is a superset of C, all of C glue can be used with C++. In addition, C++ glue provides
support for:</p>
<blockquote>
<div><ul class="simple">
<li>Constructing objects using the new operator.</li>
<li>Deleting objects using the delete operator.</li>
<li>Calling member functions on objects.</li>
</ul>
</div></blockquote>
<p>Each of these parts will be explained in the following sections.</p>
<span class="target" id="index-78"></span></div>
<div class="section" id="constructing-objects">
<span id="index-79"></span><h3>Constructing objects<a class="headerlink" href="#constructing-objects" title="Permalink to this headline">¶</a></h3>
<p>In C++, objects are constructed using the new operator. Constructors may take arguments. The
macros <tt class="docutils literal"><span class="pre">CC_new_N</span></tt> where N is a small integer, support calling constructors with or without arguments.
Calling a constructor is similar to calling a function, so for additional explanation, please
refer to section 5.13.6. Here is the general syntax for constructing objects using C++ glue:</p>
<blockquote>
<div><div class="highlight-python"><pre>CC_new_N(cnvt_res,aux_res, class, gfname, c0,a0, c1,a1, ... cN,aN)</pre>
</div>
</div></blockquote>
<p>For example, to construct a sockaddr_in† object, the following glue statement could be used:</p>
<blockquote>
<div><div class="highlight-python"><pre>CC_new_0(proxy,(sockaddr_in *,socks), sockaddr_in, new_sockaddr_in)</pre>
</div>
</div></blockquote>
<p>The meanings of the <tt class="docutils literal"><span class="pre">CC_new_N</span></tt> arguments are as follows:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">cnvt_res</span></tt>, <tt class="docutils literal"><span class="pre">aux_res:</span></tt> the result of calling the constructor is an object pointer. The result
conversion pair <tt class="docutils literal"><span class="pre">cnvt_res</span></tt>, <tt class="docutils literal"><span class="pre">aux_res</span></tt> (see Table 3), specifies how this pointer is converted
to a Self object before being returned. In the <tt class="docutils literal"><span class="pre">sockaddr</span></tt> example, the proxy result conversion
is used.</li>
<li><tt class="docutils literal"><span class="pre">class</span></tt> is the name of the class (or struct) that is being instantiated.</li>
<li><tt class="docutils literal"><span class="pre">gfname</span></tt>: the name of the C++ function that the <tt class="docutils literal"><span class="pre">CC_new_N</span></tt> macro expands into.</li>
<li><tt class="docutils literal"><span class="pre">ci</span></tt>, <tt class="docutils literal"><span class="pre">ai</span></tt>: if the constructor takes arguments, these arguments must be converted from Self
representation to C++ representation. The arguments conversion pairs <tt class="docutils literal"><span class="pre">ci</span></tt>, <tt class="docutils literal"><span class="pre">ai</span></tt> specify how
each argument is converted. See Table 3 for a description of all argument conversions. In
the sockaddr example, there are no arguments.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="deleting-objects">
<h3>Deleting objects<a class="headerlink" href="#deleting-objects" title="Permalink to this headline">¶</a></h3>
<p>C++ objects can have destructors that are executed when the objects are deleted. To ensure that the
destructor is called properly, the <tt class="docutils literal"><span class="pre">delete</span></tt> operator must know the type of the object being deleted.
This is ensured by using the <tt class="docutils literal"><span class="pre">CC_delete</span></tt> macro, which has the following form:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">CC_delete</span><span class="p">(</span><span class="n">cnvt_obj</span><span class="p">,</span><span class="n">aux_obj</span><span class="p">,</span> <span class="n">gfname</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>For example, to delete <tt class="docutils literal"><span class="pre">sockaddr_in</span></tt> objects (constructed as in the previous section), the
<tt class="docutils literal"><span class="pre">CC_delete</span></tt> macro should be used in this manner:</p>
<blockquote>
<div><div class="highlight-python"><pre>CC_delete(proxy,(sockaddr_in *,socks), delete_sockaddr_in)</pre>
</div>
</div></blockquote>
<p>In general, the meaning of the arguments given to <tt class="docutils literal"><span class="pre">CC_delete</span></tt> is:</p>
<blockquote>
<div><ul class="simple">
<li>cnvt_obj,aux_obj: this pair can be any of the argument conversions found in Table 3
that produces a pointer to the object that will be deleted.</li>
<li>gfname: the name of the C++ function that this invocation of <tt class="docutils literal"><span class="pre">CC_delete</span></tt> expands into.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="calling-member-functions">
<h3>Calling member functions<a class="headerlink" href="#calling-member-functions" title="Permalink to this headline">¶</a></h3>
<p>Table 3 lists all the available argument conversions. Each row represents one conversion, with the
first two columns designating the conversion pair. The third column lists the types of Self objects
that the conversion pair accepts. The fourth column lists the C types that it produces. The fifth column
lists the kind of errors that can occur during the conversion. Finally, the sixth column contains
references to numbered notes. The notes are found in the paragraphs following the table.</p>
<p>Calling member functions is similar to calling “plain” functions, so please also refer to section
5.13.6. The difference is that an additional object must be specified: the object upon which the
member function is invoked (the receiver in Self terms). Calling a member function is accomplished
using one of the macros</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">CC_mber_N</span><span class="p">(</span><span class="n">cnvt_res</span><span class="p">,</span><span class="n">aux_res</span><span class="p">,</span> <span class="n">cnvt_rec</span><span class="p">,</span><span class="n">aux_rec</span><span class="p">,</span> <span class="n">mname</span><span class="p">,</span> <span class="n">gfname</span><span class="p">,</span>
                                <span class="n">fail_opt</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span><span class="n">a1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">cN</span><span class="p">,</span><span class="n">aN</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>For example here is how to call the member function zock on a <tt class="docutils literal"><span class="pre">sockaddr_in</span></tt> object given by a
proxy:†</p>
<blockquote>
<div><div class="highlight-python"><pre>CC_mber_0(bool,, proxy,(sockaddr_in *,socks), zock, zock_glue,)</pre>
</div>
</div></blockquote>
<p>The arguments to <tt class="docutils literal"><span class="pre">CC_mber_N</span></tt> are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">cnvt_res</span></tt>, <tt class="docutils literal"><span class="pre">aux_res</span></tt>: this pair, which can be any of the result conversions from Table 3,
specifies how to convert the result of the member function before returning it to Self. For
example, the zock member function returns a boolean.</li>
<li><tt class="docutils literal"><span class="pre">cnvt_rec</span></tt>, <tt class="docutils literal"><span class="pre">aux_rec</span></tt>: the object on which the member function is invoked. Often this will
be a proxy conversion as in the <tt class="docutils literal"><span class="pre">zock</span></tt> example.</li>
<li><tt class="docutils literal"><span class="pre">mname</span></tt> is the name of the member function. In general, it may be any expression, such that
<tt class="docutils literal"><span class="pre">receiver-&gt;mname</span></tt> evaluates to a function.</li>
<li><tt class="docutils literal"><span class="pre">gfname</span></tt> is the name of the C++ function that the <tt class="docutils literal"><span class="pre">CC_mber_N</span></tt> macro expands into.</li>
<li><tt class="docutils literal"><span class="pre">fail_opt</span></tt>: whether or not to pass a failure handle to the member function (refer to section
5.13.6 for details).</li>
<li><tt class="docutils literal"><span class="pre">ci</span></tt>, <tt class="docutils literal"><span class="pre">ai</span></tt>: these are argument conversion pairs specifying how to obtain the arguments for the
member function. Any conversion pair found in Table 3 may be used.</li>
</ul>
</div>
<div class="section" id="conversion-pairs">
<span id="index-80"></span><h3>Conversion pairs<a class="headerlink" href="#conversion-pairs" title="Permalink to this headline">¶</a></h3>
<p>A major function of glue code is to convert between Self objects and C/C++ values. This conversion
is guarded by so-called conversion pairs. A <em>conversion pair</em> is a pair of arguments given to a
glue macro. It handles converting one or at most a few types of objects/values. There are different
conversion pairs for converting from Self objects to C/C++ values (called argument conversion
pairs) and for converting from C/C++ values to Self objects (called result conversion pairs).</p>
<span class="target" id="index-81"></span></div>
<div class="section" id="argument-conversions-from-self-to-c-c">
<span id="index-82"></span><h3>Argument conversions – from Self to C/C++<a class="headerlink" href="#argument-conversions-from-self-to-c-c" title="Permalink to this headline">¶</a></h3>
<p>An argument conversion is given a Self object and performs these actions to produce a corresponding
C or C++ value:</p>
<ul class="simple">
<li>check that the Self object† it has been given is among the allowed types. If not, report
<tt class="docutils literal"><span class="pre">badTypeError</span></tt> (invoke the failure block (if present) with the argument <tt class="docutils literal"><span class="pre">’badTypeError’</span></tt>).</li>
<li>check that the object can be converted to a C/C++ value without overflow or any other error.
If not, report the relevant error.</li>
<li>do the conversion, i.e., construct the C/C++ value corresponding to the given Self object.</li>
</ul>
<span class="target" id="index-83"></span><span class="target" id="index-84"></span><span class="target" id="index-85"></span><span class="target" id="index-86"></span><p id="index-87"><strong>Table 3 : Argument conversions - from Self to C/C++</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="14%" />
<col width="21%" />
<col width="11%" />
<col width="39%" />
<col width="6%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Conversion</th>
<th class="head">Second part</th>
<th class="head">Self type</th>
<th class="head">C/C++ type</th>
<th class="head">Errors</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>bool</td>
<td>&nbsp;</td>
<td>boolean</td>
<td>int (0 or 1)</td>
<td>badTypeError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>char</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>char</td>
<td>badTypeError overflowError</td>
<td>1</td>
</tr>
<tr class="row-even"><td>signed_char</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>signed char</td>
<td>badTypeError overflowError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>unsigned_char</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>unsigned char</td>
<td>badSignError badTypeError overflowError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>short</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>short</td>
<td>badTypeError overflowError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>signed_short</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>signed short</td>
<td>badTypeError overflowError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>unsigned_short</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>unsigned short</td>
<td>badSignError badTypeError overflowError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>int</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>int</td>
<td>badTypeError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>signed_int</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>signed int</td>
<td>badTypeError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>unsigned_int</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>unsigned int</td>
<td>badSignError badTypeError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>long</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>long</td>
<td>badTypeError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>signed_long</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>signed long</td>
<td>badTypeError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>unsigned_long</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>unsigned long</td>
<td>badSignError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>smi</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>smi</td>
<td>badTypeError</td>
<td>2</td>
</tr>
<tr class="row-even"><td>unsigned_smi</td>
<td>&nbsp;</td>
<td>smallInt</td>
<td>smi</td>
<td>badSignError badTypeError</td>
<td>2</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="14%" />
<col width="21%" />
<col width="11%" />
<col width="39%" />
<col width="6%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Conversion</th>
<th class="head">Second part</th>
<th class="head">Self type</th>
<th class="head">C/C++ type</th>
<th class="head">Errors</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>float</td>
<td>&nbsp;</td>
<td>float</td>
<td>float</td>
<td>badTypeError</td>
<td>3</td>
</tr>
<tr class="row-odd"><td>double</td>
<td>&nbsp;</td>
<td>float</td>
<td>double</td>
<td>badTypeError</td>
<td>3</td>
</tr>
<tr class="row-even"><td>long_double</td>
<td>&nbsp;</td>
<td>float</td>
<td>long double</td>
<td>badTypeError</td>
<td>3</td>
</tr>
<tr class="row-odd"><td>bv</td>
<td>ptr_type</td>
<td>byte vector</td>
<td>ptr_type</td>
<td>badTypeError</td>
<td>4</td>
</tr>
<tr class="row-even"><td>bv_len</td>
<td>ptr_type</td>
<td>byte vector</td>
<td>ptr_type, int</td>
<td>badSizeError badTypeError</td>
<td>4, 5</td>
</tr>
<tr class="row-odd"><td>bv_null</td>
<td>ptr_type</td>
<td>byte vector/0</td>
<td>ptr_type</td>
<td>badTypeError</td>
<td>4, 6</td>
</tr>
<tr class="row-even"><td>bv_len_null</td>
<td>ptr_type</td>
<td>byte vector/0</td>
<td>ptr_type, int</td>
<td>badSizeError badTypeError</td>
<td>4, 5, 6</td>
</tr>
<tr class="row-odd"><td>cbv</td>
<td>ptr_type</td>
<td>byte vector</td>
<td>ptr_type</td>
<td>badTypeError</td>
<td>7</td>
</tr>
<tr class="row-even"><td>cbv_len</td>
<td>ptr_type</td>
<td>byte vector</td>
<td>ptr_type, int</td>
<td>badSizeError badTypeError</td>
<td>7</td>
</tr>
<tr class="row-odd"><td>cbv_null</td>
<td>ptr_type</td>
<td>byte vector/0</td>
<td>ptr_type</td>
<td>badTypeError</td>
<td>7</td>
</tr>
<tr class="row-even"><td>cbv_len_null</td>
<td>ptr_type</td>
<td>byte vector/0</td>
<td>ptr_type, int</td>
<td>badSizeError badTypeError</td>
<td>7</td>
</tr>
<tr class="row-odd"><td>string</td>
<td>&nbsp;</td>
<td>byte vector</td>
<td>char *</td>
<td>badTypeError nullCharError</td>
<td>8</td>
</tr>
<tr class="row-even"><td>string_len</td>
<td>&nbsp;</td>
<td>byte vector</td>
<td>char *, int</td>
<td>badTypeError nullCharError</td>
<td>5, 8</td>
</tr>
<tr class="row-odd"><td>string_null</td>
<td>&nbsp;</td>
<td>byte vector/0</td>
<td>char *</td>
<td>badTypeError nullCharError</td>
<td>6, 8</td>
</tr>
<tr class="row-even"><td>string_len_null</td>
<td>&nbsp;</td>
<td>byte vector/0</td>
<td>char *, int</td>
<td>badTypeError nullCharError</td>
<td>5, 6, 8</td>
</tr>
<tr class="row-odd"><td>proxy</td>
<td>(ptr_type, type_seal)</td>
<td>proxy</td>
<td>ptr_type, != NULL</td>
<td>badTypeError badTypeSealError, deadProxyError,nullPointerError</td>
<td>9</td>
</tr>
<tr class="row-even"><td>proxy_null</td>
<td>(ptr_type, type_seal)</td>
<td>proxy</td>
<td>ptr_type</td>
<td>badTypeError badTypeSealError deadProxyError</td>
<td>9</td>
</tr>
<tr class="row-odd"><td>any_oop</td>
<td>&nbsp;</td>
<td>any object</td>
<td>oop</td>
<td>&nbsp;</td>
<td>10</td>
</tr>
<tr class="row-even"><td>oop</td>
<td>oop subtype</td>
<td>corresponding object</td>
<td>oop (subtype)</td>
<td>badTypeError</td>
<td>11</td>
</tr>
<tr class="row-odd"><td>any</td>
<td>C/C++ type</td>
<td>int/float/proxy/byte-vector, int</td>
<td>int/float/ptr/ptr</td>
<td>badIndexError badTypeError deadProxyError</td>
<td>12</td>
</tr>
</tbody>
</table>
<blockquote>
<div><ol class="arabic simple">
<li>The C type <tt class="docutils literal"><span class="pre">char</span></tt> has a system dependent range. Either 0..255 or -128..127.</li>
<li>The type <tt class="docutils literal"><span class="pre">smi</span></tt> is used internally in the virtual machine (a 30 bit integer).</li>
<li>Precision may be lost in the conversion.</li>
<li>The second part of the conversion is a C pointer type. The address of the first byte in the byte
vector, cast to this pointer type, is passed to the foreign routine. It is the responsibility of
the foreign routine not to go past the end of the byte vector. The foreign routine should not retain
pointers into the byte vector after the call has terminated. Note: canonical strings can not be passed
through a bv conversion (<tt class="docutils literal"><span class="pre">badTypeError</span></tt> will result). This is to ensure that they are not accidentally
modified by a foreign function.</li>
<li>This conversion passes two values to the foreign routine: a pointer to the first byte in the byte
vector, and an integer which is the length of the byte vector divided by <tt class="docutils literal"><span class="pre">sizeof(*ptr_type)</span></tt>. If
the size of the byte vector is not a multiple of <tt class="docutils literal"><span class="pre">sizeof(*ptr_type)</span></tt>, <tt class="docutils literal"><span class="pre">badSizeError</span></tt> results.</li>
<li>In addition to accepting a byte vector, this conversion accepts the integer 0, in which case a <tt class="docutils literal"><span class="pre">NULL</span></tt>
pointer is passed to the foreign routine.</li>
<li>The <tt class="docutils literal"><span class="pre">cbv</span></tt> conversions are like the bv conversions except that canonical strings are allowed as actual
arguments. A <tt class="docutils literal"><span class="pre">cbv</span></tt> conversion should only be used if it is guaranteed that the foreign routine
does not modify the bytes it gets a pointer to.</li>
<li>All the string conversions take an incoming byte vector, copy the bytes part, add a trailing null
char, and pass a pointer to this copy to the foreign routine. After the call has terminated, the copy
is discarded. If the byte vector contains a null char, <tt class="docutils literal"><span class="pre">nullCharError</span></tt> results.</li>
<li>The <tt class="docutils literal"><span class="pre">type_seal</span></tt> is an <tt class="docutils literal"><span class="pre">int</span></tt> or <tt class="docutils literal"><span class="pre">char</span></tt> * expression that is tested against the type seal value in the
proxy. If the two are different, <tt class="docutils literal"><span class="pre">badTypeSealError</span></tt> results. The special value <tt class="docutils literal"><span class="pre">ANY_SEAL</span></tt> will
match the type seal in any proxy. Note that the <tt class="docutils literal"><span class="pre">proxy</span></tt> conversion will fail with <tt class="docutils literal"><span class="pre">nullPointerError</span></tt>
if the proxy object it is given encapsulates a NULL pointer.</li>
<li>The <tt class="docutils literal"><span class="pre">any_oop</span></tt> conversion is an escape: it passes the Self object unchanged to the foreign routine.</li>
<li>The <tt class="docutils literal"><span class="pre">oop</span></tt> conversion is mainly intended for internal use. The second argument is the name of
an oop subtype. After checking that the incoming argument points to an instance of the subtype,
the pointer is cast to the subtype.</li>
<li>The <tt class="docutils literal"><span class="pre">any</span></tt> conversion is different from all other conversions in that it expects two incoming
Self objects. The actions of the conversion depends on the type of the first object in the following
way. If the first object is an integer, the second argument must also be an integer; the two integers
are converted to C <tt class="docutils literal"><span class="pre">int</span></tt>’s, the second is shifted 16 bits to the left and they are or’ed together to produce
the result. If the first object is a float, it is converted to a C <tt class="docutils literal"><span class="pre">float</span></tt> and the second object is
ignored. If the first object is a proxy, the result is the pointer represented by the proxy, and the second
argument is ignored. If the first object is a byte vector, the second object must be an integer
which is interpreted as an index into the byte vector; the result is a pointer to the indexed byte.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="result-conversions-from-c-c-to-self">
<span id="index-88"></span><h3>Result conversions - from C/C++ to Self<a class="headerlink" href="#result-conversions-from-c-c-to-self" title="Permalink to this headline">¶</a></h3>
<p>A result conversion is given a C or C++ value of a certain type and performs these actions to produce
a corresponding Self object:</p>
<blockquote>
<div><ul class="simple">
<li>check that the C/C++ value can be converted to a Self object with no overflow or other error
occurring. If not, report the error.</li>
<li>do the conversion, i.e., construct the Self object corresponding to the given C/C++ value.</li>
</ul>
</div></blockquote>
<p>Table 4 lists all the available result conversions. Each row represents one conversion, with the first
two columns designating the conversion pair. The third column lists the type of C or C++ value that
the conversion pair accepts. The fourth column lists the type of Self object the conversion produces.
The fifth column lists the kind of errors that can occur during the conversion. Finally, the sixth
column contains references to numbered notes. The notes are found in the paragraphs following
the table.</p>
<p><strong>Table 4 : Result conversions - from C/C++ to Self</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="28%" />
<col width="14%" />
<col width="14%" />
<col width="16%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Conversion</th>
<th class="head">Second part</th>
<th class="head">C/C++ type</th>
<th class="head">Self type</th>
<th class="head">Errors</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>void</td>
<td>&nbsp;</td>
<td>void</td>
<td>smallInt (0)</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>bool</td>
<td>&nbsp;</td>
<td>int</td>
<td>boolean</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>char</td>
<td>&nbsp;</td>
<td>char</td>
<td>smallInt</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>signed_char</td>
<td>&nbsp;</td>
<td>signed char</td>
<td>smallInt</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>unsigned_char</td>
<td>&nbsp;</td>
<td>unsigned char</td>
<td>smallInt</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>short</td>
<td>&nbsp;</td>
<td>short</td>
<td>smallInt</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>signed_short</td>
<td>&nbsp;</td>
<td>signed short</td>
<td>smallInt</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>unsigned_short</td>
<td>&nbsp;</td>
<td>unsigned short</td>
<td>smallInt</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>int</td>
<td>&nbsp;</td>
<td>int</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>signed_int</td>
<td>&nbsp;</td>
<td>signed int</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>unsigned_int</td>
<td>&nbsp;</td>
<td>unsigned int</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>long</td>
<td>&nbsp;</td>
<td>long</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>signed_long</td>
<td>&nbsp;</td>
<td>signed long</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>unsigned_long</td>
<td>&nbsp;</td>
<td>unsigned long</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>smi</td>
<td>&nbsp;</td>
<td>smi</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>int_or_errno</td>
<td>n</td>
<td>int</td>
<td>int</td>
<td>a UNIX error</td>
<td>1</td>
</tr>
<tr class="row-even"><td>float</td>
<td>&nbsp;</td>
<td>float</td>
<td>float</td>
<td>&nbsp;</td>
<td>2</td>
</tr>
<tr class="row-odd"><td>double</td>
<td>&nbsp;</td>
<td>double</td>
<td>float</td>
<td>&nbsp;</td>
<td>2</td>
</tr>
<tr class="row-even"><td>long_double</td>
<td>&nbsp;</td>
<td>long double</td>
<td>float</td>
<td>&nbsp;</td>
<td>2</td>
</tr>
<tr class="row-odd"><td>string</td>
<td>&nbsp;</td>
<td>char *</td>
<td>byte vector</td>
<td>nullPointerError</td>
<td>3</td>
</tr>
<tr class="row-even"><td>proxy</td>
<td>(ptr_type, type_seal)</td>
<td>ptr_type</td>
<td>proxy</td>
<td>nullPointerError</td>
<td>3, 4, 8</td>
</tr>
<tr class="row-odd"><td>proxy_null</td>
<td>(ptr_type, type_seal)</td>
<td>ptr_type</td>
<td>proxy</td>
<td>&nbsp;</td>
<td>4, 8</td>
</tr>
<tr class="row-even"><td>proxy_or_errno</td>
<td>(ptr_type, type_seal, n)</td>
<td>ptr_type</td>
<td>proxy</td>
<td>a UNIX error</td>
<td>4, 5, 8</td>
</tr>
<tr class="row-odd"><td>fct_proxy</td>
<td>(ptr_type, type_seal, arg_count)</td>
<td>ptr_type</td>
<td>fctProxy</td>
<td>nullPointerError</td>
<td>3, 6, 8</td>
</tr>
<tr class="row-even"><td>fct_proxy_null</td>
<td>(ptr_type, type_seal, arg_count)</td>
<td>ptr_type</td>
<td>fctProxy</td>
<td>&nbsp;</td>
<td>6, 8</td>
</tr>
<tr class="row-odd"><td>oop</td>
<td>&nbsp;</td>
<td>oop</td>
<td>corresponding
object</td>
<td>&nbsp;</td>
<td>7, 8</td>
</tr>
</tbody>
</table>
<blockquote>
<div><ol class="arabic simple">
<li>This conversion returns an integer value, unless the integer has the value n (the second part of
the conversion; often -1). If the integer is n, the conversion interprets the return value as a UNIX
error indicator. It then constructs a string describing the error (by looking at <tt class="docutils literal"><span class="pre">errno</span></tt>) and invokes
the “IfFail block” with this string.</li>
<li>Precision may be lost.</li>
<li>This conversion fails with <tt class="docutils literal"><span class="pre">nullPointerError</span></tt> if attempting to convert a NULL pointer.</li>
<li>The <tt class="docutils literal"><span class="pre">ptr_type</span></tt> is the C/C++ type of the pointer. The <tt class="docutils literal"><span class="pre">type_seal</span></tt> is an expression of type int
or <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt>.The conversion constructs a new proxy object, stores the C/C++ pointer in it and sets
its type seal to be the value of <tt class="docutils literal"><span class="pre">type_seal</span></tt>.</li>
<li>If the pointer is <tt class="docutils literal"><span class="pre">n</span></tt> (often <tt class="docutils literal"><span class="pre">n</span></tt> is <tt class="docutils literal"><span class="pre">NULL</span></tt>), the conversion fails with a UNIX error, similar to the way
<tt class="docutils literal"><span class="pre">int_or_errno</span></tt> may fail.</li>
<li>The <tt class="docutils literal"><span class="pre">fct_proxy</span></tt>, <tt class="docutils literal"><span class="pre">fct_proxy_null</span></tt> and <tt class="docutils literal"><span class="pre">fct_proxy_or_errno</span></tt> conversions are similar to
the corresponding proxy conversions. The difference is that they produce a <tt class="docutils literal"><span class="pre">fctProxy</span></tt> object rather
than a proxy object. Also, their second part is a triple rather than a pair. The extra component
specifies how many arguments the function takes, if called. The special keyword <tt class="docutils literal"><span class="pre">unknownNoOfArgs</span></tt>
or any nonnegative integer expression can be used here.</li>
<li>This conversion is an escape: it passes the C value unchanged to Self. It is an error to use it if
the C value is not an <tt class="docutils literal"><span class="pre">oop</span></tt>.</li>
<li>The <tt class="docutils literal"><span class="pre">proxy</span></tt> (<tt class="docutils literal"><span class="pre">fctProxy</span></tt>) object that is returned by these conversions is <em>not</em> being created by the
glue code. Rather a <tt class="docutils literal"><span class="pre">proxy</span></tt> (<tt class="docutils literal"><span class="pre">fctProxy</span></tt>) must be passed down from the Self level. This <tt class="docutils literal"><span class="pre">proxy</span></tt>
(<tt class="docutils literal"><span class="pre">fctProxy</span></tt>), a <em>result proxy</em>, will then be side effected by the glue: the value that the foreign function
returns will be stored in the result proxy together with the requested type seal. It is required
that the result proxy is dead when passed down (else a <tt class="docutils literal"><span class="pre">liveProxyError</span></tt> results). After being
side-effected and returned, the result proxy is live. The result proxy is the last argument of the
function that the glue macro expands to.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="a-complete-application-using-foreign-functions">
<h3>A complete application using foreign functions<a class="headerlink" href="#a-complete-application-using-foreign-functions" title="Permalink to this headline">¶</a></h3>
<p>This section gives a description of a complete application which uses foreign functions. The aim is
to present a realistic and complete example of how foreign functions may be used. The complete
source for the example is found in the directory <tt class="docutils literal"><span class="pre">objects/applications/serverDemo</span></tt> in the
Self distribution.</p>
<p>The example used is an application that allows Self expressions to be easily evaluated by non-
Self processes. Having this, it then becomes possible to start Self processes from a UNIX
prompt (shell) or to specify pipe lines in which some of the processes are Self processes. For example
in</p>
<blockquote>
<div><div class="highlight-python"><pre>proto% cat someFile | tokenize | sort -r | capitalize | tee lst</pre>
</div>
</div></blockquote>
<p>it may be the case that the filters tokenize and capitalize perform most of their work in Self.
Likewise, the command</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">proto</span><span class="o">%</span> <span class="n">mail</span>
</pre></div>
</div>
</div></blockquote>
<p>may invoke some fancy mail reader written in Self rather than the standard UNIX mail reader.</p>
<p>To see how the above can be accomplished, please refer to Figure 5 below. The left side of the figure
shows the external view of a typical UNIX process. It has two files: stdin and stdout (for simplicity
we ignore stderr). Stdin is often connected to the keyboard so that characters typed here can
be read from the file stdin. Likewise, stdout is typically connected to the console so that the process
can display output by writing it to the file stdout. Stdin and stdout can also be connected to “regular”
files, if the process was started with redirection. The right side of Figure 5 shows a two stage
pipe line. Here stdout of the first process is connected to stdin of the second process.</p>
<div class="figure align-left">
<a class="reference internal image-reference" href="_images/Chapter_5_Figure_5.png"><img alt="_images/Chapter_5_Figure_5.png" src="_images/Chapter_5_Figure_5.png" style="width: 680.0px; height: 86.0px;" /></a>
<p class="caption">Figure 5: A single UNIX process and an pipe line.</p>
</div>
<p>Figure 5 illustrates a simple trick that in many situations allows Self processes to behave as if they
are full-fledged UNIX processes. A Self process is represented by a “real” UNIX process which
transparently communicates with the Self process over a pair of connected sockets. The communication
is bidirectional: input to the UNIX process is relayed to the Self process over the socket
connection, and output produced by the Self process is sent over the same socket connection to
the UNIX process which relays it to stdout. The right part of Figure 5 shows how the UNIX/Self
process pair can fit seamlessly into a pipe line.</p>
<div class="figure align-left">
<a class="reference internal image-reference" href="_images/Chapter_5_Figure_6.png"><img alt="_images/Chapter_5_Figure_6.png" src="_images/Chapter_5_Figure_6.png" style="width: 680.0px; height: 208.0px;" /></a>
<p class="caption">Figure 6: A Self process and how it fits into a pipe line.</p>
</div>
<p>Source code that facilitates setting up such UNIX/Self process pairs is included in the Self distribution.
The source consists of two parts: one being a Self program (called <em>server</em>), the other being
a C++ program (called <em>toself</em>). When the server is started, it creates a socket, binds a name to it
and then listens for connections on it. <tt class="docutils literal"><span class="pre">toself</span></tt> establishes connections to the server program. The
first line that is transmitted when a connection has been set up goes from <tt class="docutils literal"><span class="pre">toself</span></tt> to the server. The
line contains a Self expression. Upon receiving it, the server forks a new process to evaluate the
expression in the context of the lobby augmented with a slot, stdio, that contains a <tt class="docutils literal"><span class="pre">unixFile</span></tt>-like
object that represents the socket connection. When the forked process terminates, the socket connection
is shut down. The <tt class="docutils literal"><span class="pre">toself</span></tt> UNIX process then terminates.</p>
<p>The Self expression that forms the Self process is specified on the command line when <tt class="docutils literal"><span class="pre">toself</span></tt>
is started. For example, if the server has been started, the following can be typed at the UNIX
prompt:</p>
<blockquote>
<div><div class="highlight-python"><pre>proto% toself stdio writeLine: 5 factorial printString
120

proto% echo something | toself capitalize: stdio
SOMETHING

proto% toself capitalize: stdio
Write some text that goes to stdin of the toself program
WRITE SOME TEXT THAT GOES TO STDIN OF THE TOSelf PROGRAM
More text
MORE TEXT
^D

proto%</pre>
</div>
</div></blockquote>
<p>If you want to try out these examples, locate the files <tt class="docutils literal"><span class="pre">server.self</span></tt>, <tt class="docutils literal"><span class="pre">socks.so</span></tt> and <tt class="docutils literal"><span class="pre">toself</span></tt>. The
path name of the file <tt class="docutils literal"><span class="pre">socks.so</span></tt> is hardwired in the file <tt class="docutils literal"><span class="pre">server.self</span></tt> so please make sure that it
has been set correctly for your system. Then file in the world and type [<tt class="docutils literal"><span class="pre">server</span> <span class="pre">start</span></tt>] <tt class="docutils literal"><span class="pre">fork</span></tt> at
the Self prompt. Now you can go back to the UNIX prompt and try out the examples shown
above.</p>
</div>
<div class="section" id="outline-of-toself">
<h3>Outline of <tt class="docutils literal"><span class="pre">toself</span></tt><a class="headerlink" href="#outline-of-toself" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">toself</span></tt> is a small C++ program found in the file <tt class="docutils literal"><span class="pre">toself.c</span></tt>. It operates in the three phases outlined
above:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Try to connect to a well-known port number on a given machine (the function <tt class="docutils literal"><span class="pre">establishConnection</span></tt>
does this).</li>
<li>Send the command line arguments over the connection established in 1 (the <tt class="docutils literal"><span class="pre">safeWrite</span></tt>
call in <tt class="docutils literal"><span class="pre">main</span></tt> does this).</li>
<li>While there is more input and the Self process has not shut down the socket connection,
relay from stdin to the socket connection and from the socket connection to stdout (the function
<tt class="docutils literal"><span class="pre">relay</span></tt> does this).</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="outline-of-server">
<h3>Outline of server<a class="headerlink" href="#outline-of-server" title="Permalink to this headline">¶</a></h3>
<p>The server is a Self program. It is found in the file <tt class="docutils literal"><span class="pre">server.self</span></tt>. When the server is started, the
following happens:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Create a socket, bind a name to it and start listening.</p>
</li>
<li><dl class="first docutils">
<dt>Loop: accept a connection and fork a new process (both step 1 and 2 are performed by the method <tt class="docutils literal"><span class="pre">server</span> <span class="pre">start</span></tt>). The forked process executes the method <tt class="docutils literal"><span class="pre">server</span> <span class="pre">handleRequest</span></tt> which:</dt>
<dd><ol class="first last loweralpha simple">
<li>Reads a line from the connection.</li>
<li>Sets up a context with a slot <tt class="docutils literal"><span class="pre">stdio</span></tt> referring to the connection.</li>
<li>Evaluates the line read in step (a) in this context.</li>
<li>Closes the connection.</li>
</ol>
</dd>
</dl>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="foreign-functions-and-glue-needed-to-implement-server">
<h3>Foreign functions and glue needed to implement server<a class="headerlink" href="#foreign-functions-and-glue-needed-to-implement-server" title="Permalink to this headline">¶</a></h3>
<p>The server program needs to do a number of UNIX calls to create sockets and bind names to them
etc. The calls needed are <tt class="docutils literal"><span class="pre">socket</span></tt>, <tt class="docutils literal"><span class="pre">bind</span></tt>, <tt class="docutils literal"><span class="pre">listen</span></tt>, <tt class="docutils literal"><span class="pre">accept</span></tt> and <tt class="docutils literal"><span class="pre">shutdown</span></tt>. The first three of these
are only called in a fixed sequence, so to make things easier, a small C++ function
<tt class="docutils literal"><span class="pre">socket_bind_listen</span></tt>, that bundles them up in the right sequence, has been written. The <tt class="docutils literal"><span class="pre">accept</span></tt>
function is more general than what is needed for this application, so a wrapper function,
<tt class="docutils literal"><span class="pre">simple_accept</span></tt>, has been written. The result is that the server needs to call only three foreign
functions: <tt class="docutils literal"><span class="pre">socket_bind_listen</span></tt>, <tt class="docutils literal"><span class="pre">simple_accept</span></tt> and <tt class="docutils literal"><span class="pre">shutdown</span></tt>. Glue for these three functions
and the source for the first two is found in the file <tt class="docutils literal"><span class="pre">socks.c</span></tt>. This file is compiled and linked
using the <tt class="docutils literal"><span class="pre">Makefile</span></tt>. The result is a shared object file, <tt class="docutils literal"><span class="pre">socks.so</span></tt>.</p>
</div>
<div class="section" id="use-of-foreign-functions-in-server-self">
<h3>Use of foreign functions in server.self<a class="headerlink" href="#use-of-foreign-functions-in-server-self" title="Permalink to this headline">¶</a></h3>
<p>The server program is implemented using <tt class="docutils literal"><span class="pre">foreignFct</span></tt> objects. There is only a few lines of code
directly involved in setting this up. First the <tt class="docutils literal"><span class="pre">foreignFct</span></tt> prototype is cloned to obtain a “local
prototype”, called <tt class="docutils literal"><span class="pre">socksFct</span></tt>, which contains the path for the <tt class="docutils literal"><span class="pre">socks.so</span></tt> file. <tt class="docutils literal"><span class="pre">socksFct</span></tt> is then
cloned each time a <tt class="docutils literal"><span class="pre">foreignFct</span></tt> object for a function defined in <tt class="docutils literal"><span class="pre">socks.so</span></tt> is needed. For example,
in <tt class="docutils literal"><span class="pre">traits</span> <span class="pre">socket</span></tt>, the following method is found:</p>
<blockquote>
<div><div class="highlight-python"><pre>copyPort: portNumber = ( "Create a socket, do bind, then listen."
                | sbl = socksFct copyName: ’socket_bind_listen_glue’. |
                sbl value: portNumber With: deadCopy.
        ).</pre>
</div>
</div></blockquote>
<p>This method copies a <tt class="docutils literal"><span class="pre">socket</span></tt> object and returns the copy. The local slot <tt class="docutils literal"><span class="pre">sbl</span></tt> is initialized to a
<tt class="docutils literal"><span class="pre">foreignFct</span></tt> object. The body of the method simply sends <tt class="docutils literal"><span class="pre">value:With:</span></tt> to the <tt class="docutils literal"><span class="pre">foreignFct</span></tt>
object. The first argument is the port number to request for the socket, the second argument is a
<tt class="docutils literal"><span class="pre">deadCopy</span></tt> of self (socket objects are proxies and <tt class="docutils literal"><span class="pre">socket_bind_listen</span></tt> returns a proxy, so it
must be passed a dead proxy to revive and store the result in; see section 5.13.1).</p>
<p>There are only three uses of <tt class="docutils literal"><span class="pre">foreignFct</span></tt> objects in the server and in all three cases, the <tt class="docutils literal"><span class="pre">foreignFct</span></tt>
object is encapsulated in a method as illustrated above.</p>
<p>In general the design of <tt class="docutils literal"><span class="pre">foreignFct</span></tt> objects has been aimed at making the use of them light
weight. When cloning them, it is only necessary to specify the minimal information: the name of
the foreign function. They can be encapsulated in a method thus localizing the impact of redesigns.
The complications of dynamic loading and linking are handled automatically, as is the recovery of
dead <tt class="docutils literal"><span class="pre">fctProxies</span></tt>.</p>
<p class="rubric" id="index-89">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>The bracketed colon indicates that the argument is optional (i.e., there are two versions of the primitive, one taking an argument and one not taking an argument). The bracket is not part of the primitive name. See text for details.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="morphic.html">Morphic: The Self User Interface Framework</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="buildvm.html">Building a VM</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2014, Russell Allen (Ed.).
      Last updated on Jan 05, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>