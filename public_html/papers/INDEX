%X This file contains and index of the papers in this directory.
%X uh 3/94
%X bwc 1/95

%A Ungar, D.
%A Smith, R.B.
%D Dec 1987
%T Self: The Power of Simplicity
%B Proceedings OOPSLA '87, ACM SIGPLAN Notices
%V 22
%N 12
%P 227-242
%J Proceedings OOPSLA '87, ACM SIGPLAN Notices
%X Self is an object-oriented language for exploratory programming based
on a small number of simple and concrete ideas: prototypes, slots, and
behavior. Prototypes combine inheritance and instantiation to provide
a framework that is simpler and more flexible than most
object-oriented languages. Slots unite variables and procedures into a
single construct. This permits the inheritance hierarchy to take over
the function of lexical scoping in conventional languages.  Finally,
because Self does not distinguish state from behavior, it narrows the
gaps between ordinary objects, procedures, and closures. Self's
simplicity and expressiveness offer new insights into object-oriented
computation.
%X selfPower.ps.Z

%A Ungar, David
%A Chambers, Craig
%A Chang, Bay-Wei
%A Holzle, Urs
%D 1991
%T Organizing programs without classes
%B Lisp and Symbolic Computation
%V 4
%N 3
%P 223-242
%X All organizational functions carried out by classes can be accomplished in
 a simple and natural way by object inheritance in classless languages, with
 no need for special mechanisms. A single model-dividing types into
 prototypes and traits-supports sharing of behavior and extending or
 replacing representations. A natural extension, dynamic object inheritance,
 can model behavioral modes. Object inheritance can also be used to provide
 structured name spaces for well-known objects. Classless languages can even
 express 'class-based' encapsulation. These stylized uses of object
 inheritance become instantly recognizable idioms, and extend the repertory
 of organizing principles to cover a wider range of programs.
%X organizing.ps.Z

%A Chambers, Craig
%A Ungar, David
%A Chang, Bay-Wei
%A Holzle, Urs
%D 1991
%T Parents are shared parts of objects: inheritance and encapsulation in SELF
%B Lisp and Symbolic Computation
%V 4
%N 3
%P 207-222
%X The design of inheritance and encapsulation in SELF, an object-oriented
 language based on prototypes, results from understanding that inheritance
 allows parents to be shared parts of their children. The programmer
 resolves ambiguities arising from multiple inheritance by prioritizing an
 object's parents. Unifying unordered and ordered multiple inheritance
 supports differential programming of abstractions and methods, combination
 of unrelated abstractions, unequal combination of abstractions, and mixins.
 In SELF, a private slot may be accessed if the sending method is a shared
 part of the receiver, allowing privileged communication between related
 objects. Thus, classless SELF enjoys the benefits of class-based
 encapsulation.
%X inheritance.ps.Z

%0 Technical Report
%A Chang, Bay-Wei
%A Ungar, David
%D 1990
%T Experiencing Self Objects: An Object-Based Aritificial Reality
%B The Self Papers
%I Stanford University
%X Our prototype user interface for Self provides browsing and inspecting
of Self objects by combining an object-based model with an artificial
reality. Emphasizing the problem-domain objects rather than views of
those objects discards a layer of indirection found in conventional
window-based user interfaces. Placing those objects in an artificial
reality reduces the cognitive load on the programmer, by exploiting
the programmer's already internalized knowledge of how objects in the
physical world behave. Our goal is to make the user interface
invisible, and thus make Self objects and the Self world real.
%X ui.ps.Z

%A Chambers, C.
%A Ungar, D.
%A Lee, E.
%D Oct 1989
%T An Efficient Implementation of SELF -- a Dynamically-Typed Object-Oriented Language Based on Prototypes
%B Proceedings OOPSLA '89, ACM SIGPLAN Notices
%V 24
%N 10
%P 49-70
%J Proceedings OOPSLA '89, ACM SIGPLAN Notices
%X  We have developed and implemented techniques that double the
performance of dynamically-typed object-oriented languages. Our SELF
implementation runs twice as fast as the fastest Smalltalk
implementation, despite SELF's lack of classes and explicit variables.
To compensate for the absence of classes, our system uses
implementation-level maps to transparently group objects cloned from
the same prototype, providing data type information and eliminating
the apparent space overhead for prototype-based systems. To compensate
for dynamic typing, user-defined control structures, and the lack of
explicit variables, our system dynamically compiles multiple versions
of a source method, each customized according to its receiver's map.
Within each version the type of the receiver is fixed, and thus the
compiler can statically bind and inline all messages sent to self.
Message splitting and type prediction extract and preserve even more
static type information, allowing the compiler to inline many other
messages. Inlining dramatically improves performance and eliminates
the need to hard-wire low-level methods such as +, =\x12=, and
ifTrue:.
Despite inlining and other optimizations, our system still supports
interactive programming environments. The system traverses internal
dependency lists to invalidate all compiled methods affected by a
programming change. The debugger reconstructs inlined stack frames
from compiler- generated debugging information, making inlining
invisible to the SELF programmer.
%X oopsla89.ps.Z

%0 Conference Proceedings
%A Chambers, Craig
%A Ungar, David
%D 1991
%T Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs
%B PLDI'90
%X sigplan90.ps.Z

%A Holzle, U.
%A Chambers, C.
%A Ungar, D.
%D July 15-19, 1991
%T Optimizing Dynamically-Typed Object-Oriented Languages With Polymorphic Inline Caches
%B ECOOP '91 Proceedings
%E P. America
%I Springer-Verlag
%C Geneva, Switzerland
%P 21-38
%X ecoop91.ps.Z
%X %X Polymorphic inline caches (PICs) provide a new way to reduce the overhead
    of polymorphic message sends by extending inline caches to include more
    than one cached lookup result per call site. For a set of typical
    object-oriented SELF programs, PICs achieve a median speedup of 11%. As an
    important side effect, PICs collect type information by recording all of
    the receiver types actually used at a given call site. The compiler can
    exploit this type information to generate better code when recompiling a
    method. An experimental version of such a system achieves a median speedup
    of 27% for the set of SELF programs, reducing the number of non-inlined
    message sends by a factor of two. Implementations of dynamically-typed
    object-oriented languages have been limited by the paucity of type
    information available to the compiler. The abundance of the type
    information provided by PICs suggests a new compilation approach for these
    languages, adaptive compilation. Such compilers may succeed in generating
    very efficient code for the time-critical parts of a program without
    incurring distracting compilation pauses.

%A Chambers, C.
%A Ungar, D.
%D Nov 1991
%T Making Pure Object-Oriented Languages Practical
%B Proceedings OOPSLA '91, ACM SIGPLAN Notices
%V 26
%N 11
%P 1-15
%J Proceedings OOPSLA '91, ACM SIGPLAN Notices
%X oopsla91.ps.Z

%0 Thesis
%A Chambers, Craig
%D 1992
%T The Design and Implementation of the SELF Compiler, an Optimizing Compiler for Object-Oriented Programming Languages
%I Computer Science Department, Stanford University
%9 Ph.D. Thesis

%0 Conference Proceedings
%A Holzle, Urs
%A Chambers, Craig
%A Ungar, David
%D 1992
%T Debugging Optimized Code With Dynamic Deoptimization
%B PLDI'92
%I SIGPLAN Notices
%C San Francisco
%V 27
%N 6
%P 21-38
%X The SELF debugging system provides complete source-level debugging
    (expected behavior) with globally optimized code. It shields the debugger
    from optimizations performed by the compiler by dynamically deoptimizing
    code on demand. Deoptimization requires the compiler to supply debugging
    information at discrete interrupt points; the compiler can still perform
    extensive optimizations between interrupt points without affecting
    debuggability. The debugging system also handles programming changes during
    debugging. Again, the system provides expected behavior: it is possible to
    change a running program and immediately observe the effects of the change.
    Dynamic deoptimization transforms old compiled code into new versions
    reflecting the current source-level state.
%X pldi92.ps.Z

%A Ungar, David
%A Smith, Randall B.
%A Chambers, Craig
%A Holzle, Urs
%D 1992
%T Object, Message, and performance: How they coexist in Self
%B IEEE Computer
%V 25
%N 10
%P 53-64
%X The Self programming language, which distills object-oriented computation
    down to a simple story based on copying prototypes to create objects,
    inheriting from objects to share their contents, and passing messages to
    invoke methods, is discussed. It is shown that Self's uniform application
    of the object-message paradigm gives programmers unusual flexibility.
    Unconventional optimizations can bring its peak performance to within a
    factor of two of optimized C's performance. Overviews of Self and its
    message passing performance are presented.
%X ieee-computer.ps.Z

%0 Book Section
%A Agesen, Ole
%A Palsberg, Jens
%A Schwartzbach, Michael I.
%D July 1993
%T Type Inference of SELF: Analysis of Objects with Dynamic and Multiple Inheritance
%B Proceedings ECOOP '93
%E O. Nierstrasz
%I Springer-Verlag
%C Kaiserslautern, Germany
%P 247-267
%X We have designed and implemented a type inference algorithm for the full Self language. The algorithm can guarantee the safety and disambiguity of message sends, and provide useful information for browsers and optimizing compilers. Self features objects with dynamic inheritance. This construct has until now been considered incompatible with type inference because it allows the inheritance graph to change dynamically. Our algorithm handles this by deriving and solving type constraints that simultaneously define supersets of both the possible values of expressions and of the possible inheritance graphs. The apparent circularity is resolved by computing a global fixed-point, in polynomial time. The algorithm has been implemented and can successfully handle the Self benchmark programs, which exist in the "standard Self world" of more than 40,000 lines of code.
%X ecoop93a.ps.Z

%0 Book Section
%A Agesen, Ole
%D September 1994
%T Constraint-Based Type Inference and Parametric Polymorphism
%B Proceedings SAS'94
%E Le Charlier, Baudouin
%I Springer-Verlag LNCS 864
%C Namur, Belgium
%P 78-100
%X Constraint-based analysis is a technique for inferring implementation
   types. Traditionally it has been described using mathematical
   formalisms. We explain it in a different and more intuitive way as a
   flow problem. The intuition is facilitated by a direct correspondence
   between run-time and analysis-time concepts.
   Precise analysis of polymorphism is hard; several algorithms have been
   developed to cope with it. Focusing on parametric polymorphism and
   using the flow perspective, we analyze and compare these algorithms,
   for the first time directly characterizing when they succeed and fail.
   Our study of the algorithms lead us to two conclusions. First,
   designing an algorithm that is either efficient or precise is easy, but
   designing an algorithm that is efficient and precise is hard. Second,
   to achieve efficiency and precision simultaneously, the analysis effort
   must be actively guided towards the areas of the program with the
   highest pay-off. We define a general class of algorithms that do this:
   the adaptive algorithms. The two most powerful of the five algorithms
   we study fall in this class.
%X sas94.ps.Z

%0 Book Section
%A Holzle, Urs
%D July 1993
%T Integrating Independently-Developed Components in Object-Oriented Languages
%B Proceedings ECOOP '93
%E O. Nierstrasz
%I Springer-Verlag
%C Kaiserslautern, Germany
%P 36-56
%X Object-oriented programming promises to increase programmer productivity through better reuse of existing code. However, reuse is not yet pervasive in today's object-oriented programs. Why is this so? We argue that one reason is that current programming languages and environments assume that components are perfectly coordinated. Yet in a world where programs are mostly composed out of reusable components, these components are not likely to be completely integrated because the sheer number of components would make global coordination impractical. Given that seemingly minor inconsistencies between individually designed components would exist, we examine how they can lead to integration problems with current programming language mechanisms. We discuss several reuse mechanisms that can adapt a component in place without requiring access to the component's source code and without needing to re-typecheck it.
%X ecoop93b.ps.Z

%0 Conference Proceedings
%A Chang, Bay-Wei
%A Ungar, David
%D 1993
%T Animation: From cartoons to the User Interface
%B UIST'93
%C Atlanta, GA
%X User interfaces are often based on static presentations, a 
   model ill suited for conveying change. Consequently, events 
   on the screen frequently startle and confuse users. Cartoon 
   animation, in contrast, is exceedingly successful at engaging 
   its audience; even the most bizarre events are easily 
   comprehended. The Self user interface has served as a 
   testbed for the application of cartoon animation techniques 
   as a means of making the interface easier to understand and 
   more pleasant to use. Attention to timing and transient detail 
   allows Self objects to move solidly. Use of cartoon-style 
   motion blur allows Self objects to move quickly and still 
   maintain their comprehensibility. Self objects arrive and 
   depart smoothly, without sudden materializations and 
   disappearances, and they rise to the front of overlapping 
   objects smoothly through the use of dissolve. Anticipating 
   motion with a small contrary motion and pacing the middle 
   of transitions faster than the endpoints results in smoother 
   and clearer movements. Despite the differences between 
   user interfaces and cartoons--cartoons are frivolous, 
   passive entertainment and user interfaces are serious, 
   interactive tools--cartoon animation has much to lend to 
   user interfaces to realize both affective and cognitive 
   benefits.
%X uist93.ps.Z

%0 Conference Proceedings
%A Holzle, Urs
%D October 1993
%T A Fast Write Barrier for Generational Garbage Collectors
%B OOPSLA'93 GC workshop
%X write-barrier.ps.Z
%X Generational garbage collectors need to keep track of references from
older to younger generations so that younger generations can be
garbage-collected without inspecting every object in the older
generation(s). The set of locations potentially containing pointers to
newer objects is often called the remembered set. At every store, the
system must ensure that the updated location is added to the
remembered set if the store creates a reference from an older to a
newer object. This mechanism is usually referred to as a write barrier
or store check.
For some stores, the compiler can know statically that no store check
is necessary, for example, when storing an integer (assuming that
integers are implemented as immediates rather than as real
heap-allocated objects). However, in the general case, a store check
must be executed for every store operation. Since stores are fairly
frequent in non-functional languages, an efficient write barrier
implementation is essential. The write barrier implementation
described here reduces the write barrier overhead in the mutator to
only two extra instructions per checked store.


%0 Conference Proceedings
%A Holzle, Urs
%A Ungar, David
%D 1994
%T Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback
%B PLDI'94
%I SIGPLAN Notices
%P 326-336
%C Orlando, FL
%8 June 1994
%X Object-oriented programs are difficult to optimize
because they execute many dynamically-dispatched calls. These
calls cannot easily be eliminated because the compiler does not
know which callee will be invoked at runtime. We have developed
a simple technique that feeds back type information from the
runtime system to the compiler. With this type feedback, the
compiler can inline any dynamically-dispatched call. Our compiler
drastically reduces the call frequency of a suite of large SELF applications
 (by a factor of 3.6) and improves performance by a factor
of 1.7. We believe that type feedback could significantly reduce
call frequencies and improve performance for most other object-
oriented languages (statically-typed or not) as well as for
languages with type-dependent operations such as generic arithmetic.
%X pldi94.ps.Z


%0 Technical Report
%A Agesen, Ole
%D 1994
%T Mango - A Parser Generator for Self
%I Sun Microsystems Laboratories Technical Report TR-94-27
%8 June 1994
%X Mango is a parser generator that is included in Release 3.0 of the
Self system.  Mango goes beyond LEX/YACC in several respects.  First,
Mango grammars are structured, thus easier to read and map onto parse
trees.  Second, Mango parsers automatically build parse trees rather
than merely provide hooks for calling low-level reduce actions during
parsing.  Third, Mango automatically maintains invariance of the
structure of parse trees, even while grammars are transformed to enable
LR parsing.  Fourth, Mango and the parsers it generates are completely
integrated in the Self object world.  In particular, a parser is an
object.  Unike YACC, several independent parsers can co-exist in a
single program.
We show how to generate a Mango parser and how to use it by means of an 
example: a simple expression language.  Furthermore, we show how to add 
semantic properties to the parse trees that the Mango parser produces.
Mango is a realistic tool.  A parser for full ANSI C was built with Mango.    
%X mango.ps.Z

%A Urs Holzle
%T Adaptive Optimization for SELF: Reconciling High Performance with Exploratory Programming
%D 1994
%I Stanford University, Computer Science Department
%X Ph. D. Thesis
%X Crossing abstraction boundaries often incurs a substantial run-time
overhead in the form of frequent procedure calls.  Thus, pervasive use
of abstraction, while desirable from a design standpoint, may lead to
very inefficient programs.  Aggressively optimizing compilers can
reduce this overhead but conflict with interactive programming
environments because they introduce long compilation pauses and often
preclude source-level debugging. Thus, programmers are caught on the
horns of two dilemmas: they have to choose between abstraction and
efficiency, and between respon sive programming environments and
efficiency. This dissertation shows how to reconcile these seemingly
contradic tory goals by performing optimizations lazily.
Four new techniques work together to achieve this:
- Type feedback achieves high performance by allowing the compiler to
inline message sends based on information extracted from the runtime
system. On average, programs run 1.5 times faster than the previous
SELF system; compared to a commercial Smalltalk implementation, two
medium-sized benchmarks run about three times faster.  This level of
performance is obtained with a compiler that is both simpler and
faster than previous SELF compilers.
- Adaptive optimization achieves high responsiveness without sacrificing
performance by using a fast compiler to generate initial code while
automatically recompiling heavily used program parts with an
optimizing compiler. On a previous-generation workstation like the
SPARCstation-2, fewer than 200 pauses exceeded 200 ms during a 50-
minute interaction, and 21 pauses exceeded one second. On a
current-generation workstation, only 13 pauses exceed 400 ms.
- Dynamic deoptimization shields the programmer from the complexity of
debugging optimized code by transparently recreating non-optimized
code as needed. No matter whether a program is optimized or not, it
can always be stopped, inspected, and single-stepped. Compared to
previous approaches, deoptimization allows more debugging while
placing fewer restrictions on the optimizations allowed.
- Polymorphic inline caching generates type-case sequences on-the-fly to
speed up messages sent from the same call site to several different
types of objects. More significantly, they collect concrete type
information for the compiler.
With better performance yet good interactive behavior, these
techniques reconcile exploratory programming, ubiqui tous abstraction,
and high performance.
%X hoelzle-thesis.ps.Z

%0 Conference Proceedings
%A Holzle, Urs
%A Ungar, David
%D 1994
%T A Third-Generation Self Implementation: Reconciling Responsiveness
with Performance
%B OOPSLA'94
%I SIGPLAN Notices
%C Portland, OR
%8 August 1994
%X Programming systems should be both responsive (to support rapid
development) and efficient (to complete computations quickly). Pure
object-oriented languages are harder to implement efficiently since
they need optimization to achieve good performance. Unfortunately,
optimization conflicts with in teractive responsiveness because it
tends to produce long compilation pauses, leading to unresponsive
programming environments. Therefore, to achieve good responsiveness,
existing exploratory programming environments such as the Smalltalk-80
environment rely on interpretation or non-optimizing dynamic
compilation. But such systems pay a price for their interactive ness,
since they may execute programs several times slower than an
optimizing system.
SELF-93 reconciles high performance with responsive ness by combining
a fast, non-optimizing compiler with a slower, optimizing compiler.
The resulting system achieves both excellent performance (two or three
times faster than existing Smalltalk systems) and good responsiveness.
Except for situations requiring large applications to be (re)compiled
from scratch, the system allows for pleasant interactive use with few
perceptible compilation pauses. To our knowledge, SELF- 93 is the
first implementation of a pure object-oriented language achieving both
good performance and good responsiveness.
When measuring interactive pauses, it is imperative to treat multiple
short pauses as one longer pause if the pauses occur in short
succession, since they are perceived as one pause by the user. We
propose a definition of pause clustering and show that clustering can
make an order-of-magnitude difference in the pause time distribution.
%X oopsla94a.ps.Z

%0 Conference Proceedings
%A Agesen, Ole
%A Ungar, David
%D 1994
%T Sifting Out the Gold: Delivering Compact Applications
From an Exploratory Object-Oriented Environment
%B OOPSLA'94
%I SIGPLAN Notices
%C Portland, OR
%8 October 1994
%X Integrated, dynamically-typed object-oriented programming environments
offer many advantages, but have trouble producing small, self-contained 
applications. Recent advances in type inference have made it possible to 
build an application extractor for Self. The extractor was able to extract 
a medium-sized application in a few minutes. The extracted application runs 
in a tenth the space of the original environment. Except for extracting 
reflection and sends with computed selectors, the extractor runs without 
human intervention and fully preserves the behavior of the application. 
%X oopsla94b.ps.Z

%0 Book Section
%A Chang, Bay-Wei
%A Ungar, David
%A Smith, Randall B.
%D 1995
%T Getting Close to Objects
%B Visual Object-Oriented Programming
%E Burnett, Margaret M.
%E Goldberg, Adele
%E Lewis, Ted G.
%I Prentice-Hall
%P 185-198
%X Current visual programming environments make use of 
   views and tools to present objects. These view-focused 
   environments provide great functionality at the expense of 
   distancing the objects behind the intermediary layers of 
   views and tools. We propose the object-focused model, 
   which attempts to foster the notion that objects themselves 
   are directly available for interaction. Unique, directly 
   manipulable representations of objects make them 
   immediate, and basing functionality on the object rather 
   than on extrinsic tools makes them the primary loci of 
   action. But although immediacy and primacy contribute to 
   the sense of concreteness of the objects, discarding 
   conventional views and tools potentially restrict the 
   functionality of the environment. Fortunately, by being 
   extremely faithful to the notion of concreteness of objects, 
   two principles emerge that allow object-focused 
   environments to match the functionality of view-focused 
   environments. The principle of availability makes 
   functionality of objects accessible across contexts, and the 
   principle of liveliness allows objects to participate in 
   multiple contexts while retaining concreteness. All these 
   elements help make objects seem more real in the object-
   focused environment, hopefully lessening some of the 
   cognitive burden of programming by reducing the distance 
   between the programmer's mental model of objects and the 
   environment's representation of objects. Programmers can 
   get the sense that the objects on the screen are the objects in 
   the program, and thus can think about working with objects 
   rather than manipulating the environment.
%X voop.ps.Z
