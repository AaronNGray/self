<TITLE>The Self Virtual Machine</TITLE>

<H2>Important types and type hierachies</H2>

<H3>Pointers and oops</H3>

The class hierachy rooted at oopClass describes Self objects of various kinds. A pointer of one of these types can be used to manipulate the underlying Self object from within C++. Note that the pointer is not the same as the Self oop that refers to that object. Self oops are tagged. The various kinds of pointers have been typedef'd in types.h to have short aliases. Typically, if the C++ class is known as fooOopClass, foo is a typedef for fooOopClass*. <P>

oopClass::tag() returns the tag; it is a 2-bit integer, and can distinguish between immediate integers (smiOopClass), immediate floats (floatOopClass), memory-based objects (i.e., "typical" objects) (the hierachy rooted at memOopClass), and a special mark word that is used at the beginning of objects (markOopClass). The tag can be tested with is_smi(), is_mem(), is_float() and is_mark(). <P>

<H3>The "memOop" hierachy</H3>

Every memOop object starts with a mark word and a map word. ... <P>

<H3>Marks</H3>
The mark word at the start of each object delimits objects in memory (by virtue of the special tag) and also contains several fields used elsewhere: <P>

  <OL>
  <LI> The age field...
  <LI> The hash field...
  <LI> The marked field...
  </OL>


Given a pointer into the middle of an object, find_this_object() will find the start of that object (by searching down through memory until it hits a mark), except during garbage collection, when the marks have been altered (see later). <P>

<H3>Maps</H3>

Underlying each object is a map...needs some explanation... <P>

oopClass::map() returns a pointer to an object's map. It does this by first examining the tag of the oop; integers, floats, and marks have maps that are known to the VM. memOops get their maps from memory (the _map field of memOopClass). <P>

<H3>The Map Chain</H3>
